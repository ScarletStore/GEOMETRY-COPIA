<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Yuri 22 Dash Pro - By Dino.Editxx</title> {/* Título Simplificado */}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Estilos gerais */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Impede barras de rolagem */
            height: 100%;     /* Garante que o body ocupe toda a altura */
            background-color: #000; /* Fundo preto padrão */
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            overscroll-behavior: none; /* Evita refresh ao puxar em mobile */
            display: flex; /* Para centralizar o game-container */
            justify-content: center;
            align-items: center;
        }

        /* Container principal */
        .game-container {
            position: relative; /* Necessário para posicionamento absoluto interno */
            width: 100vw; /* Ocupa toda a largura da viewport */
            height: 100vh; /* Ocupa toda a altura da viewport */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Centraliza verticalmente */
            align-items: center;     /* Centraliza horizontalmente */
            max-width: 100%; /* Garante que não exceda a largura da tela */
            max-height: 100%; /* Garante que não exceda a altura da tela */
        }

        canvas {
            display: block; /* Remove espaço extra abaixo do canvas */
            border: 3px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; /* Mantém proporção */
            image-rendering: pixelated; /* Mantém estilo pixelado */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* Container para botões p5 */
        #p5ButtonContainer {
            position: absolute;
            bottom: 80px; /* Ajustado para dar espaço aos créditos */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
            gap: 15px; /* Espaçamento entre botões */
        }

        /* Botões p5.js (usados no menu, game over, win) */
        .p5Button {
            font-size: clamp(12px, 2.5vw, 16px);
            padding: 12px 20px;
            cursor: pointer;
            border: 2px solid #fff;
            border-radius: 5px;
            background-color: #4CAF50; /* Verde padrão (Jogar/Reiniciar) */
            color: #fff;
            /* margin: 8px 0; */ /* Removido para usar gap */
            transition: background-color 0.2s, transform 0.1s;
            font-family: 'Press Start 2P', cursive;
            box-shadow: 0 4px #388E3C;
            text-shadow: 1px 1px 2px black;
            min-width: 180px;
            text-align: center;
        }
        .p5Button.secondary { /* Para botões como Instruções, Voltar ao Menu */
             background-color: #2196F3; /* Azul */
             box-shadow: 0 4px #1976D2;
        }
        .p5Button.secondary:hover { background-color: #64b5f6; }
        .p5Button.secondary:active { transform: translateY(2px); box-shadow: 0 2px #1976D2; }

        .p5Button:hover { background-color: #66BB6A; }
        /* Ajuste :active para não depender do translateX que já está no #p5ButtonContainer */
        .p5Button:active { transform: translateY(2px); box-shadow: 0 2px #388E3C; }


        /* Botões de overlay (Voltar, Skins, Pausa, Habilidade) */
        .overlay-button {
            position: absolute;
            padding: 8px 12px;
            font-size: clamp(9px, 1.8vw, 12px);
            z-index: 10;
            display: none; /* Começam escondidos */
            cursor: pointer;
            border: 2px solid #fff;
            border-radius: 5px;
            color: #fff;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.1s, filter 0.2s;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 1px 1px 2px black;
            -webkit-tap-highlight-color: transparent;
        }
        .overlay-button:active:not(:disabled) { transform: translateY(2px); }
        .overlay-button:disabled { cursor: not-allowed; filter: grayscale(70%); opacity: 0.7;}

        #backButton { top: 15px; left: 15px; background-color: #f44336; box-shadow: 0 3px #D32F2F; }
        #backButton:hover { background-color: #ef5350; }
        #backButton:active { box-shadow: 0 1px #D32F2F; }

        #skinButton { top: 15px; right: 15px; background-color: #00B8D4; box-shadow: 0 3px #0097A7; }
        #skinButton:hover { background-color: #26C6DA; }
        #skinButton:active { box-shadow: 0 1px #0097A7; }

        #pauseButton { top: 60px; left: 15px; background-color: #FFA000; box-shadow: 0 3px #FF6F00; }
        #pauseButton:hover { background-color: #FFB300; }
        #pauseButton:active { box-shadow: 0 1px #FF6F00; }

        /* Botão de Habilidade */
        #abilityButton {
            bottom: 20px;
            left: 15px;
            background-color: #7e57c2; /* Roxo */
            box-shadow: 0 3px #5e35b1;
            display: flex; /* Alterado para flex via JS em changeState */
            align-items: center;
            justify-content: center;
            padding: 10px; /* Quadrado */
            min-width: 40px;
            font-size: 10px; /* Menor */
        }
        #abilityButton:hover:not(:disabled) { background-color: #9575cd; }
        #abilityButton:active:not(:disabled) { box-shadow: 0 1px #5e35b1; }
        #abilityButton svg { width: 18px; height: 18px; /* margin-right: 5px; */ } /* Removido margin-right */
        #abilityButton .ability-text { display: inline; margin-left: 5px;} /* Aumentado margin-left */
        /* Ícones de habilidade - visibilidade controlada por JS (updateAbilityButton) */

        /* Contêiner de Skins */
        #skinContainer {
            display: none; /* Controlado por JS */
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            z-index: 20;
            flex-direction: column;
            align-items: center;
            border: 2px solid #00ffff;
            max-height: 70vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #00ffff #333;
            top: 60px; /* Posição inicial, será ajustada pelo JS */
            right: 15px;
        }
        #skinContainer::-webkit-scrollbar { width: 8px; }
        #skinContainer::-webkit-scrollbar-track { background: #333; border-radius: 4px; }
        #skinContainer::-webkit-scrollbar-thumb { background-color: #00ffff; border-radius: 4px; border: 1px solid #333; }

        .skin-entry { margin-bottom: 15px; text-align: center; cursor: pointer; position: relative; }
        .skinOption {
            width: 60px; height: 60px; border: 3px solid transparent; border-radius: 8px;
            transition: border-color 0.3s, transform 0.2s;
            object-fit: cover; background-color: #555; display: block; margin: 0 auto 5px auto;
            image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;
        }
        /* Estilo para imagem de erro (quando src não carrega) */
        img.skinOption[src="about:blank"], img.skinOption:error {
            /* Tenta mostrar placeholder via CSS se JS falhar */
            content: 'ERR'; /* Isso não funciona bem em <img>, o JS onerror é melhor */
            background-color: #ccc;
            color: black;
            text-align: center;
            line-height: 60px; /* Centraliza verticalmente */
            font-size: 14px;
        }
        .skin-entry.locked .skinOption { filter: grayscale(100%); cursor: not-allowed; }
        .skin-entry:not(.locked):hover .skinOption { border-color: #fff; transform: scale(1.1); }
        .skin-entry.selected .skinOption { border-color: #FFD700 !important; box-shadow: 0 0 10px #FFD700; transform: scale(1.1); }
        .skin-name { font-size: 10px; color: #fff; margin-top: 2px; }
        .skin-rarity { font-size: 9px; font-weight: bold; }
        .skin-unlock { font-size: 8px; color: #ccc; margin-top: 2px; }
        .rarity-Comum { color: #ffffff; } .rarity-Incomum { color: #66BB6A; } .rarity-Raro { color: #42A5F5; } .rarity-Épico { color: #AB47BC; } .rarity-Lendário { color: #FFA726; } .rarity-Boss { color: #ff4d4d; } /* Nova raridade */
        .lock-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.7); border-radius: 8px; opacity: 0; transition: opacity 0.2s; pointer-events: none; }
        .skin-entry.locked .lock-overlay { opacity: 1; pointer-events: all; }
        .lock-overlay svg { color: #ffcc00; margin-bottom: 5px; width: 20px; height: 20px; }
        .lock-overlay span { font-size: 9px; color: #ffcc00; }

        /* UI (Score, Nível, Nick (agora profile), Vidas, Timer, Boss) */
        .ui-element {
            position: absolute;
            color: #FFD700;
            text-shadow: 1px 1px 3px black;
            z-index: 5;
            font-size: clamp(11px, 2vw, 16px);
            display: none; /* Começa escondido */
            white-space: nowrap; /* Evita quebra de linha */
        }
        #scoreDisplay { top: 20px; left: 50%; transform: translateX(-50%); }
        #levelDisplay { top: 40px; left: 50%; transform: translateX(-50%); font-size: clamp(10px, 1.8vw, 14px); color: #00ffff; }
        /* #nicknameDisplay foi movido para #profileArea */
        #livesDisplay {
            top: 20px; /* Alinhado com Score */
            right: 15px; /* Canto superior direito */
            color: #ff4d4d; /* Vermelho claro */
            font-size: clamp(12px, 2.2vw, 18px);
        }
        #timerDisplay {
            top: 60px; /* Abaixo do level */
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(10px, 1.8vw, 14px);
            color: #FFA500;
        }
        #bossCountdown { /* Agora usado para próximo Boss também */
            top: 80px; /* Abaixo do timer normal */
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(10px, 1.8vw, 14px);
            color: #FF4500; /* Laranja avermelhado */
        }
        /* NOVO: Barra de Vida do Boss */
        #bossHealthBarContainer {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 40vw, 300px);
            height: 20px;
            background-color: rgba(80, 80, 80, 0.8);
            border: 2px solid #FF4500;
            border-radius: 5px;
            display: none; /* Começa escondido */
            z-index: 6;
        }
        #bossHealthBar {
            height: 100%;
            width: 100%; /* Controlado por JS */
            background: linear-gradient(to right, #ff0000, #ff4500, #ff8c00);
            border-radius: 3px;
            transition: width 0.3s ease-out;
        }
        #bossHealthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(9px, 1.8vw, 12px);
            color: #fff;
            text-shadow: 1px 1px 1px #000;
            white-space: nowrap;
        }


        #pauseOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: none; justify-content: center; align-items: center; font-size: clamp(24px, 5vw, 40px); color: #FFA000; z-index: 15; text-align: center; flex-direction: column; }
        #levelUpDisplay { position: absolute; top: 30%; left: 50%; transform: translateX(-50%); font-size: clamp(20px, 4vw, 32px); color: lime; text-shadow: 2px 2px 5px black; opacity: 0; transition: opacity 0.5s ease-out, transform 0.3s ease-out; /* Adicionado transform transition */ z-index: 16; pointer-events: none; }
        #loadingMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; color: #fff; text-shadow: 1px 1px 3px black; z-index: 30; display: none; }

        /* Painel de Instruções */
        #instructionsPanel {
            display: none; /* Controlado por JS */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(280px, 80vw, 500px);
            max-height: 80vh;
            background-color: rgba(10, 10, 30, 0.95);
            border: 3px solid #00ffff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.7);
            color: #fff;
            padding: 25px;
            z-index: 100;
            border-radius: 10px;
            flex-direction: column;
        }
        #instructionsPanel h2 {
            font-size: clamp(16px, 3vw, 22px);
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            color: #FFD700;
        }
        #instructionsContent {
            font-size: clamp(10px, 1.8vw, 14px);
            line-height: 1.6;
            overflow-y: auto; /* Scroll se conteúdo for grande */
            margin-bottom: 20px;
            flex-grow: 1; /* Ocupa espaço disponível */
        }
         #instructionsContent ul { padding-left: 20px; margin-top: 10px;}
         #instructionsContent li { margin-bottom: 8px; }
         #instructionsContent strong { color: #00ffff; } /* Destaca teclas e ações */
         #instructionsContent .new-feature { color: #ffeb3b; font-weight: bold; } /* Destaca novidades */
         #instructionsContent .boss-feature { color: #ff8c00; font-weight: bold; } /* Destaca novidades do Boss */
        #instructionsPanel button {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 2vw, 15px);
            padding: 10px 18px;
            cursor: pointer;
            border: 2px solid #f44336;
            border-radius: 5px;
            background-color: #d32f2f;
            color: #fff;
            transition: background-color 0.2s;
            align-self: center; /* Centraliza o botão */
            box-shadow: 0 3px #a02424;
        }
        #instructionsPanel button:hover { background-color: #e57373; }
        #instructionsPanel button:active { transform: translateY(1px); box-shadow: 0 1px #a02424;}

        /* Nickname Input Area */
        #nicknameArea {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Modificado para flex em JS */
            flex-direction: column;
            align-items: center;
            z-index: 6;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #aaa;
        }
        #nicknameArea label { margin-bottom: 8px; font-size: 12px;}
        #nicknameInput {
            font-family: 'Press Start 2P', cursive;
            background-color: #333;
            color: #fff;
            border: 1px solid #888;
            padding: 8px;
            font-size: 14px;
            width: 180px;
            text-align: center;
            margin-bottom: 10px;
        }
        #nicknameButton { /* Estilo similar aos botões p5 */
            font-size: 12px; padding: 8px 15px; cursor: pointer; border: 2px solid #fff; border-radius: 5px;
            background-color: #2196F3; color: #fff; transition: background-color 0.2s; font-family: 'Press Start 2P', cursive;
            box-shadow: 0 3px #1976D2; text-shadow: 1px 1px 2px black;
        }
        #nicknameButton:hover { background-color: #64b5f6; }
        #nicknameButton:active { transform: translateY(1px); box-shadow: 0 1px #1976D2; }

        /* Rodapé com Créditos */
        #footerCredits {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(8px, 1.5vw, 10px);
            color: #aaa;
            text-align: center;
            z-index: 1;
            width: 90%;
        }
        #footerCredits a { color: #00ffff; text-decoration: none; margin: 0 5px;}
        #footerCredits a:hover { text-decoration: underline; }
        #footerCopyright { margin-left: 10px; } /* Espaçamento para copyright */


        /* Menu de Cores das Partículas */
        #particleColorSelector {
            position: absolute;
            bottom: 20px;
            right: 15px;
            background-color: rgba(0,0,0,0.85); /* Levemente mais opaco */
            padding: 12px; /* Mais padding */
            border-radius: 5px;
            border: 2px solid #00ffff; /* Borda mais grossa */
            z-index: 10;
            display: none; /* Começa escondido, mostrado no menu */
            flex-direction: column;
            align-items: flex-end;
            gap: 5px; /* Espaço entre label e cores */
        }
        #particleColorSelector label {
            font-size: 10px; /* Um pouco maior */
            margin-bottom: 5px;
            color: #00ffff;
            align-self: center; /* Centraliza label */
        }
        .color-option {
            width: 22px; /* Maior */
            height: 22px;
            border: 2px solid #fff;
            border-radius: 50%;
            /* margin-top: 4px; */ /* Usando gap agora */
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s; /* Adicionado border-color transition */
        }
        .color-option:hover { transform: scale(1.15); border-color: #ddd; } /* Hover sutil */
        .color-option.selected {
             box-shadow: 0 0 10px #FFD700, 0 0 5px #FFD700 inset; /* Brilho mais intenso */
             border-color: #FFD700;
             transform: scale(1.1); /* Destaca um pouco */
        }

        /* NOVA SEÇÃO: Profile Area (Menu) */
        #profileArea {
            position: absolute;
            top: 15px;
            left: 15px;
            display: none; /* Controlado pelo changeState */
            align-items: center;
            background-color: rgba(20, 20, 50, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #00aaff;
            z-index: 11;
            gap: 10px;
        }
        #profilePic {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 2px solid #FFD700;
            background-color: #555;
            background-size: cover;
            background-position: center;
            image-rendering: pixelated;
        }
        #profileInfo {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
        }
        #profileNicknameDisplay { /* ID específico para o nick no perfil */
           color: #90ee90; /* Verde claro */
           font-size: clamp(10px, 1.8vw, 14px);
           text-shadow: 1px 1px 2px black;
        }
        #profileLevelDisplay { /* ID específico para o level no perfil */
            color: #00ffff;
            font-size: clamp(9px, 1.6vw, 12px);
            text-shadow: 1px 1px 2px black;
        }
        #profileSettingsIcon {
            color: #aaa;
            cursor: pointer;
            transition: color 0.2s, transform 0.2s;
            margin-left: 5px; /* Espaço do texto */
        }
        #profileSettingsIcon:hover {
            color: #fff;
            transform: rotate(45deg);
        }

        /* Efeito Reviver */
        .revive-flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0); /* Começa transparente */
            pointer-events: none;
            z-index: 100;
            animation: reviveFlash 0.6s ease-out forwards;
        }

        @keyframes reviveFlash {
            0% { background-color: rgba(255, 255, 255, 0); }
            50% { background-color: rgba(255, 255, 255, 0.7); }
            100% { background-color: rgba(255, 255, 255, 0); }
        }

         /* NOVO: Estilo para Mensagem na Tela (Desenhado no Canvas) */
         /* #gameMessageDisplay { } - Estilos não necessários pois será desenhado no p5 */

    </style>
</head>
<body>
    <div class="game-container" id="gameContainer">
        <button id="backButton" class="overlay-button">Voltar</button>
        <button id="skinButton" class="overlay-button">Skins</button>
        <button id="pauseButton" class="overlay-button">Pausar</button>
        <button id="abilityButton" class="overlay-button locked" disabled>
            <i data-lucide="lock"></i>
            <i data-lucide="zap" style="display:none;"></i> {/* Ícone para Esquiva/Tiro */}
            <i data-lucide="timer" style="display:none;"></i> {/* Ícone para Cooldown */}
            <span class="ability-text"></span>
        </button>

        <div id="scoreDisplay" class="ui-element">Score: 0</div>
        <div id="levelDisplay" class="ui-element">Nível: 1</div>
        <div id="livesDisplay" class="ui-element">Vidas: 1</div> {/* Mostra 1 (Revive) */}
        <div id="timerDisplay" class="ui-element">Tempo: 0:00</div> {/* Começa em 0 */}
        {/* Reutilizado para Spawn e Respawn do Boss */}
        <div id="bossCountdown" class="ui-element">Boss em: 50s</div>
        {/* NOVO: Barra de Vida do Boss */}
        <div id="bossHealthBarContainer">
            <div id="bossHealthBar"></div>
            <div id="bossHealthText">BOSS</div>
        </div>

        <div id="profileArea">
            <div id="profilePic"></div>
            <div id="profileInfo">
                <div id="profileNicknameDisplay">Nick: Convidado</div>
                 <div id="profileLevelDisplay">Nível Máx: 1</div>
            </div>
            <i id="profileSettingsIcon" data-lucide="settings"></i>
        </div>

        <div id="pauseOverlay">JOGO PAUSADO<br><span style="font-size: clamp(14px, 2.5vw, 20px);">Pressione 'P' ou Toque para continuar</span></div>
        <div id="levelUpDisplay">LEVEL UP!</div>
        <div id="skinContainer"></div>
        <div id="p5ButtonContainer"></div>
        <div id="instructionsPanel">
            <h2>Instruções do Jogo</h2>
            <div id="instructionsContent">
                <ul>
                    <li><strong>PC:</strong> Use <strong>[ESPAÇO]</strong> ou <strong>[SETA P/ CIMA]</strong> para pular (aperte novamente no ar para pulo duplo).</li>
                    <li><strong>Mobile:</strong> Toque na tela para pular (toque novamente no ar para pulo duplo).</li>
                    <li>Desvie dos obstáculos (espinhos <strong style="color: #ff4d4d;">vermelhos</strong>, blocos <strong style="color: #c8c8dc;">cinzas</strong>, círculos <strong style="color: #32c832;">verdes</strong>, etc.).</li>
                    <li>Colidir <strong>após reviver</strong> é Game Over! Você tem <strong>1 chance</strong> de reviver.</li>
                    <li>Sobreviva o máximo que puder! (Não há mais limite de tempo para vencer).</li>
                    <li><span class="new-feature">O primeiro <strong>Boss</strong> aparece após <strong>50 segundos</strong>.</span></li>
                    <li><span class="new-feature">Após derrotar um Boss, um <strong>novo Boss mais forte</strong> aparece a cada <strong>20 segundos</strong>.</span></li>
                    <li>Contra o Boss:
                        <ul>
                            <li>A chance de reviver ainda se aplica. Ser atingido por um projétil usa a chance ou causa Game Over.</li>
                            <li><span class="boss-feature">O Boss mostrará um <strong>AVISO (círculo vermelho)</strong> onde o ataque vai ocorrer!</span></li>
                            <li><span class="boss-feature">Os projéteis agora parecem <strong>bolas de fogo</strong>.</span></li>
                            <li><span class="boss-feature">A <strong>barra de vida</strong> do Boss aparece na parte inferior.</span></li>
                            <li><span class="boss-feature">Bosses de nível mais alto têm <strong>mais vida</strong>.</span></li>
                        </ul>
                     </li>
                    <li><strong>Habilidades (Botão <i data-lucide="zap" style="width:1em; height:1em; vertical-align:middle;"></i>):</strong>
                        <ul>
                            <li><strong>Nível 3:</strong> Libera <strong>"Esquiva Rápida"</strong> (teleporte curto para frente).</li>
                            <li><strong>Nível 6:</strong> A habilidade se torna <strong>"Tiro Certeiro"</strong>. Use <strong>somente</strong> quando o Boss estiver ativo.</li>
                            <li>A habilidade tem um <strong>cooldown</strong> (tempo de recarga).</li>
                            <li>Para "Tiro Certeiro": <span class="new-feature"><strong>Clique 3 vezes</strong> no botão rapidamente para derrotar o boss!</span></li>
                        </ul>
                    </li>
                    <li><strong>Pausa:</strong> Use <strong>'P'</strong> no PC ou o botão 'Pausar'/'Continuar'.</li>
                    <li>Use <strong>'Skins'</strong> para escolher seu cubo (desbloqueadas com nível máximo salvo).</li>
                    <li>Escolha a <strong>cor das partículas</strong> do seu personagem no menu de cores (canto inferior direito do menu).</li>
                    <li>Insira seu <strong>Nickname</strong> no menu inicial!</li>
                    <li>Seu <strong>perfil</strong> (foto e nível máx) aparece no canto superior esquerdo do menu.</li>
                </ul>
            </div>
            <button id="closeInstructionsButton">Fechar</button>
        </div>

        <div id="nicknameArea" style="display: none;">
            <label for="nicknameInput">Digite seu Nickname:</label>
            <input type="text" id="nicknameInput" maxlength="12">
            <button id="nicknameButton">Salvar Nick</button>
        </div>

        <div id="particleColorSelector">
            <label>Cor Partícula:</label>
            </div>

    </div>
    <div id="loadingMessage">Carregando Jogo...</div>

    <div id="footerCredits">
        Site feito por dino.editxx |
        <a href="https://www.tiktok.com/@dino.editxx" target="_blank" rel="noopener noreferrer">TikTok</a> |
        <a href="https://discord.gg/d9NzbRaV2N" target="_blank" rel="noopener noreferrer">Discord</a>
        <span id="footerCopyright"></span> </div>

    <script>
        // --- Variáveis Globais ---
        let gameState = "loading"; // Estados: loading, nickname, menu, play, paused, gameover
        let player;
        let obstacles = [];
        let playerParticles = []; // Partículas do jogador
        let stars = [];
        let score = 0;
        let currentLevel = 1;
        let highestLevelReached = 1; // Nível mais alto salvo
        const levelScoreThresholds = [null, 0, 5, 15, 30, 50, 75, 100, 150, 200, 300, 500, 750, 1000, 1500, 2000]; // Score para subir de nível
        let groundMargin = 100; // Valor inicial, será recalculado

        // Elementos HTML
        let backButton, skinButton, pauseButton, abilityButton;
        let skinContainer, loadingMessage, scoreDisplay, levelDisplay, pauseOverlay, levelUpDisplay, timerDisplay;
        let bossCountdownDisplay, livesDisplay;
        let gameCanvas;
        let gameContainer;
        let p5ButtonContainer; // Container dos botões p5
        let instructionsPanel, instructionsContent, closeInstructionsButton;
        let nicknameArea, nicknameInput, nicknameButton;
        let particleColorSelector;
        let profileArea, profilePic, profileNicknameDisplay, profileLevelDisplay, profileSettingsIcon; // NOVOS Elementos Profile
        let footerCopyright; // Elemento do copyright no rodapé
        let bossHealthBarContainer, bossHealthBar, bossHealthText; // NOVO: Elementos Barra Vida Boss

        // Botões p5.js (serão criados/removidos dinamicamente)
        let playButtonP5, instructionsButtonP5, gameOverMenuButtonP5, gameOverRestartButtonP5;

        // Skins (Verifique se estas URLs estão corretas e acessíveis!)
        const playerSkins = {
             // Skins existentes
             yuri_comum: { name: "Yuri Comum", rarity: "Comum", color: [0, 220, 255], face: '^_^', unlockLevel: 1, img: "https://cdn-images.dzcdn.net/images/cover/9ad0856732e7a5956e41919dd4ed33f1/0x1900-000000-80-0-0.jpg", loadedImg: null },
             yuri_basico: { name: "Yuri Básico", rarity: "Comum", color: [255, 235, 59], face: 'o_O', unlockLevel: 1, img: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRGnEw8jxlv5W1kYttbQZgkRmtkq5pfvKj24g&s", loadedImg: null },
             yuri_pro: { name: "Yuri Pro", rarity: "Incomum", color: [255, 87, 34], face: '>.<', unlockLevel: 2, img: "https://i.ytimg.com/vi/oww6D8hBGVI/hq720.jpg?sqp=-oaymwE7CK4FEIIDSFryq4qpAy0IARUAAAAAGAElAADIQj0AgKJD8AEB-AH-CYAC0AWKAgwIABABGEcgYihlMA8=&rs=AOn4CLCUD0TXzNi7OE-3HgSktm16llK-iQ", loadedImg: null },
             amigo_1: { name: "Boca de 09", rarity: "Incomum", color: [150, 150, 150], face: '0_9', unlockLevel: 3, img: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ8QwnAUxu4fo8tT-oDFO2bCK_lVpxvHqRHgg&s", loadedImg: null },
             amigo_2: { name: "Cerol", rarity: "Raro", color: [200, 200, 50], face: ':)', unlockLevel: 4, img: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQiYPbcCfBhv8ttC3NKJm7Hf23MR0l31aWs5w&s", loadedImg: null },
             amigo_3: { name: "Racha", rarity: "Raro", color: [50, 50, 200], face: '-_-', unlockLevel: 5, img: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR9_pahmiu-38qcjMSK7ImwCzVM0qByFUa9rA&s", loadedImg: null },
             yuri_palmeiras: { name: "Yuri Palmeiras", rarity: "Épico", color: [0, 100, 0], face: 'P!', unlockLevel: 6, img: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSr_xoFmN7lWWuwIkfSDBfuNk2ddvnT2zBQIA&s", loadedImg: null },
             yuri_ouro: { name: "Yuri Dourado", rarity: "Épico", color: [255, 215, 0], face: '$_$', unlockLevel: 7, img: null, loadedImg: null }, // Exemplo sem imagem URL
             yuri_ninja: { name: "Yuri Ninja", rarity: "Lendário", color: [40, 40, 40], face: 'X_X', unlockLevel: 8, img: null, loadedImg: null },
             yuri_fantasma: { name: "Yuri Fantasma", rarity: "Lendário", color: [200, 200, 255, 180], face: 'o.o', unlockLevel: 9, img: null, loadedImg: null },
             yuri_dev: { name: "Yuri DEV", rarity: "Lendário", color: [0, 255, 0], face: '</>', unlockLevel: 10, img: null, loadedImg: null },
             // NOVAS SKINS BOSS
             boss_nobru1: { name: "Boss Nobru 1", rarity: "Boss", color: [200, 50, 50], face: 'N1!', unlockLevel: 11, img: "https://www.pichauarena.com.br/wp-content/uploads/2021/12/nobru-fluxo-estudio-lbff5-1536x1024.jpg-1024x1024.webp", loadedImg: null },
             boss_nobru2: { name: "Boss Nobru 2", rarity: "Boss", color: [50, 50, 200], face: 'N2?', unlockLevel: 12, img: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT0nlLWCGXDOzpiHSizl5ggaDgH8o1x6o3lrQ&s", loadedImg: null }
             // Adicionar mais skins se quiser...
        };
        let selectedSkinKey = "yuri_comum";
        let assetsReady = false;
        let menuBgImg;
        let bossImg; // Imagem do *inimigo* Boss

        // Timer
        let gameTimer = 0; // Começa em 0
        let gameStartTime = 0;

        // Boss Inimigo
        let boss = null;
        const BOSS_APPEAR_TIME = 50; // Tempo para o PRIMEIRO boss aparecer (segundos)
        let bossLevel = 1; // Nível do Boss atual (para dificuldade)
        let bossRespawnTimer = -1; // Timer para respawn após derrota (-1 = inativo)
        const BOSS_RESPAWN_INTERVAL = 20 * 60; // 20 segundos em frames (a 60fps)
        const BOSS_ATTACK_WARNING_DURATION = 45; // Duração do aviso em frames (0.75s a 60fps)

        // Nickname
        let playerNickname = "Convidado";

        // Vidas e Reviver
        let playerLives = 1; // Só tem a chance de reviver
        const MAX_PLAYER_LIVES = 1;
        let hasRevived = false; // Controle de revive
        let reviveShakeTimer = 0;
        let reviveLightTimer = 0;

        // Habilidade
        let abilityAvailable = false; // Se o nível da habilidade foi atingido
        let currentAbilityType = null; // null, 'dodge', 'kill'
        let abilityReady = false; // Se pode ser usada (não está em cooldown)
        let abilityCooldownTimer = 0;
        const ABILITY_COOLDOWN = 300; // Cooldown em frames (5 segundos a 60fps)
        const DODGE_DISTANCE = 150; // Distância do teleporte/esquiva
        let killAbilityClicks = 0; // Contador para matar o boss

        // Partículas do Jogador
        let playerParticleColor = [255, 255, 255]; // Cor padrão branca
        const PLAYER_PARTICLE_COLORS = { // Opções de cores
            white: [255, 255, 255],
            cyan: [0, 255, 255],
            yellow: [255, 255, 0],
            lime: [0, 255, 0],
            pink: [255, 105, 180]
        };

        // Zoom Effect
        let zoomLevel = 1.0;
        let targetZoom = 1.0; // Alvo do zoom (será alterado por estado)
        let zoomChangeSpeed = 0.03; // Velocidade da transição do zoom (mais suave)

        // Mensagens na Tela
        let displayMessage = "";
        let displayMessageTimer = 0; // Contagem em frames

        // --- p5.js Funções Principais ---
        function preload() {
            console.log("Preload: Carregando assets...");
             try {
                 menuBgImg = loadImage("https://i.ytimg.com/vi/TZK5pljuSJQ/hq720.jpg?sqp=-oaymwE7CK4FEIIDSFryq4qpAy0IARUAAAAAGAElAADIQj0AgKJD8AEB-AH-CYAC0AWKAgwIABABGH8gEygYMA8=&rs=AOn4CLC0pHGHqhlRcyB16Sh8IjoaSUDGuQ",
                     () => console.log("Preload: Imagem do menu carregada."),
                     (e) => { console.error("Preload: Erro ao carregar imagem do menu.", e); menuBgImg = null; }
                 );

                 const bossImageUrl = "https://portalglobocidade.com.br/images/noticias/3570/540e617681471a13b456aee2277dcd37.jpg";
                 bossImg = loadImage(bossImageUrl,
                     () => console.log("Preload: Imagem do boss (Nobru) carregada."),
                     (e) => { console.error(`Preload: Erro ao carregar imagem do boss (${bossImageUrl}). Usando fallback.`, e); bossImg = null; }
                 );

                 console.log("Preload: Carregando imagens das skins...");
                 for (const key in playerSkins) {
                     const skin = playerSkins[key];
                     if (skin.img) {
                         // Adiciona timestamp para tentar evitar cache agressivo em alguns casos
                         const imageUrlWithTimestamp = skin.img + "?t=" + new Date().getTime();
                         skin.loadedImg = loadImage(imageUrlWithTimestamp,
                             () => { /* Log sucesso silencioso */ },
                             (e) => {
                                 console.error(`Preload: Erro ao carregar imagem da skin '${skin.name}' (${skin.img}). URL pode estar inválida, bloqueada por CORS ou problema de cache.`, e);
                                 skin.loadedImg = null; // Garante fallback
                             }
                         );
                     } else {
                         skin.loadedImg = null;
                     }
                 }
                 console.log("Preload: Solicitações de carregamento de assets concluídas.");
             } catch (e) {
                 console.error("Preload: Erro geral no carregamento.", e);
                 menuBgImg = null; bossImg = null;
                 for (const key in playerSkins) { playerSkins[key].loadedImg = null; }
             }
        }

        function setup() {
            console.log("Setup: Iniciando");
            gameContainer = select('#gameContainer');
            p5ButtonContainer = select('#p5ButtonContainer');

            // CHÃO MAIS ALTO: Ajustado cálculo da margem
            groundMargin = constrain(windowHeight * 0.15, 80, 150);

            gameCanvas = createCanvas(windowWidth, windowHeight);
            gameCanvas.parent(gameContainer);
            console.log(`Setup: Canvas criado ${width}x${height}, Margem Chão: ${groundMargin}`);

            getHtmlElements(); // Pega elementos HTML
            if (loadingMessage) loadingMessage.style.display = 'block';

            // Adiciona listener de toque no canvas (APENAS CANVAS)
            gameCanvas.touchStarted(handleCanvasTouch);

             // Carrega dados salvos
             loadGameData(); // Carrega nick, level, skin, cor

            // Espera fontes e finaliza setup
            document.fonts.ready.then(() => {
                console.log("Setup: Fontes prontas!");
                // Inicializa Lucide Ícones aqui se ainda não tiverem sido
                if (typeof lucide !== 'undefined' && !window.lucideIconsInitialized) {
                    try { lucide.createIcons(); window.lucideIconsInitialized = true; } catch(e) { console.warn("Erro ao inicializar ícones Lucide na fonte pronta:", e); }
                }
                finishSetup();
            }).catch(error => {
                console.error("Setup: Erro ao esperar fontes, usando fallback timeout:", error);
                setTimeout(finishSetup, 1500);
            });
        }

        function finishSetup() {
            if (assetsReady) return;
            console.log("Setup: Finalizando configuração...");
            assetsReady = true;

             // Aplica Nickname e Level Máximo carregados na área de perfil
             updateProfileArea(); // Atualiza a área de perfil com dados carregados

             if (nicknameInput) nicknameInput.value = playerNickname !== "Convidado" ? playerNickname : "";

             // Adiciona Copyright ao rodapé
             if (footerCopyright) {
                 const currentYear = new Date().getFullYear();
                 footerCopyright.textContent = `© ${currentYear} dino.editxx`;
             }

            // Cria jogador
            if (!player) {
                try {
                    player = new Player();
                    console.log("Setup: Jogador criado.");
                    // Aplica skin inicial (se válida)
                     if (playerSkins[selectedSkinKey] && highestLevelReached >= playerSkins[selectedSkinKey].unlockLevel) {
                         player.setAppearance(playerSkins[selectedSkinKey]);
                     } else { // Se a skin salva não for válida ou estiver bloqueada, volta para a comum
                         selectedSkinKey = "yuri_comum";
                         if (playerSkins[selectedSkinKey]) {
                             player.setAppearance(playerSkins[selectedSkinKey]);
                             saveGameData(); // Salva a skin padrão como selecionada
                         }
                     }
                     updateProfilePic(); // Atualiza a foto de perfil inicial
                } catch (e) {
                    console.error("ERRO CRÍTICO ao criar Player:", e);
                    if (loadingMessage) loadingMessage.innerText = "Erro ao criar jogador!";
                    return;
                }
            } else {
                player.reset();
                console.log("Setup: Jogador resetado.");
                 updateProfilePic(); // Garante que a foto do perfil está correta
            }

            createStars();

            // Cria botões p5.js INICIAIS (Menu)
            createMenuButtons(); // Função separada para criar botões do menu

            configureOverlayButtons();
            // populateSkinContainer(); // Popula SÓ quando abre
            updateSelectedSkinVisual(); // Marca a skin inicial salva
            setupParticleColorSelector(); // Configura seletor de cor

             // Inicializa Lucide Ícones (garante que rodem após elementos serem criados)
             if (typeof lucide !== 'undefined') {
                 try { lucide.createIcons(); } catch(e) { console.warn("Erro ao criar ícones Lucide no finishSetup:", e); }
             }

            if (loadingMessage) loadingMessage.style.display = 'none';

            // Verifica se tem nickname, se não, vai para a tela de nickname
            if (!playerNickname || playerNickname === "Convidado") {
                 changeState("nickname");
            } else {
                 changeState("menu");
            }

            console.log("Setup: Configuração completa. Estado inicial:", gameState);
              console.log(`Setup: Nível Máximo Salvo: ${highestLevelReached}, Skin Salva: ${selectedSkinKey}, Nick: ${playerNickname}, Cor Partícula: ${playerParticleColor}`);
        }

        function draw() {
            if (!assetsReady) return;

            try {
                // --- Efeito de Shake (Reviver) ---
                push(); // Isola o shake
                if(reviveShakeTimer > 0) {
                    translate(random(-6, 6), random(-5, 5)); // Aumenta intensidade do shake
                    reviveShakeTimer--;
                }
                 // --- Efeito de Luz Branca (Reviver) ---
                if (reviveLightTimer > 0) { // Atualiza timer aqui
                    reviveLightTimer--;
                }


                // --- Atualização do Zoom ---
                zoomLevel = lerp(zoomLevel, targetZoom, zoomChangeSpeed);

                // --- Aplica Zoom e Camera (centraliza a tela e aplica zoom) ---
                push(); // Isola transformações de câmera/zoom
                translate(width / 2, height / 2); // Move origem para o centro
                scale(zoomLevel); // Aplica o zoom atual
                translate(-width / 2, -height / 2); // Move origem de volta para o canto

                // Desenho Fundo
                if ((gameState === 'menu' || gameState === 'nickname') && menuBgImg) {
                    image(menuBgImg, 0, 0, width, height);
                } else if (gameState !== 'loading') {
                    drawBackground();
                } else {
                    background(0);
                }

                // Lógica e Desenho por Estado
                switch (gameState) {
                    case "nickname":
                        showNicknameScreen();
                        break;
                    case "menu":
                        showMenuScreen();
                        break;
                    case "play":
                        runGameScreen();
                        break;
                    case "paused":
                        showPausedScreen();
                        break;
                    case "gameover":
                        showGameOverScreen();
                        break;
                }

                // Desenha partículas do jogador (em todos os estados exceto loading/nickname)
                if (gameState !== 'loading' && gameState !== 'nickname') {
                    updateAndDrawPlayerParticles();
                }

                 // Desenha Nickname acima do jogador - Dentro do push/pop do zoom
                 if (player && (gameState === 'play' || gameState === 'paused')) {
                    push();
                    fill(200, 255, 200, 200); // Cor semi-transparente
                    textSize(constrain(player.w * 0.25, 8, 12)); // Tamanho relativo à largura do jogador
                    textAlign(CENTER, BOTTOM);
                    noStroke();
                    text(playerNickname, player.x, player.y - player.h / 2 - 8); // Posiciona acima
                    pop();
                 }

                 // NOVO: Desenha Mensagem na Tela (Dentro do push/pop do zoom)
                 if (displayMessageTimer > 0) {
                    push();
                    // Calcula alpha com fade-out rápido no final
                    let alphaValue = 255;
                    if (displayMessageTimer < 60) { // Fade out nos últimos 60 frames (1 segundo)
                         alphaValue = map(displayMessageTimer, 0, 60, 0, 255);
                    }
                    fill(255, 255, 0, alphaValue); // Amarelo com fade
                    textSize(min(width * 0.03, height * 0.04, 20)); // Tamanho da fonte
                    textAlign(CENTER, TOP);
                    noStroke();
                    textStyle(BOLD); // Negrito para destacar
                    text(displayMessage, width / 2, 20); // Posição no topo, centralizado
                    textStyle(NORMAL); // Reset text style
                    pop();

                    if (!['paused'].includes(gameState)) { // Não diminui timer se pausado
                         displayMessageTimer--;
                    }
                 }

                 // NOVO: Desenha Aviso e Projéteis do Boss (Dentro do push/pop do zoom)
                 if (boss && (gameState === 'play' || gameState === 'paused')) { // Desenha parado se pausado
                     boss.drawProjectilesAndWarning();
                 }


                pop(); // Restaura transformações de câmera/zoom
                pop(); // Restaura transformações do shake

                // --- UI desenhada DEPOIS do pop(), para não ser afetada pelo zoom/shake ---
                // Os elementos UI (score, level etc) são HTML, não precisam ser redesenhados aqui.
                // NOVO: Atualiza Barra de Vida do Boss (HTML)
                if (boss && (gameState === 'play' || gameState === 'paused')) {
                    updateBossHealthBar();
                } else if (bossHealthBarContainer && bossHealthBarContainer.style.display !== 'none') {
                    bossHealthBarContainer.style.display = 'none'; // Esconde se não houver boss ou não estiver jogando/pausado
                }


                // Atualiza cooldown da habilidade (se não estiver pausado)
                if (gameState === 'play' && abilityCooldownTimer > 0) {
                    abilityCooldownTimer--;
                    if (abilityCooldownTimer === 0) {
                        abilityReady = true;
                        updateAbilityButton(); // Atualiza estado do botão
                        console.log("Habilidade Pronta!");
                        showMessage("Habilidade Carregada!", 120); // Mensagem
                    }
                     // Atualizar texto do botão com cooldown restante
                     else { updateAbilityButton(); } // Atualiza para mostrar contador de cooldown
                }


            } catch (e) {
                console.error("ERRO no loop draw():", e);
                background(0); fill(255,0,0); textAlign(CENTER, CENTER); textSize(16); textStyle(NORMAL);
                text("Ocorreu um erro no jogo.\nVerifique o console (F12).", width/2, height/2);
                noLoop(); gameState = "error";
            }
        }

        // --- Funções de Estado ---

        function showNicknameScreen() {
            // A área de input é controlada pelo changeState
              textAlign(CENTER, CENTER);
              textSize(min(width * 0.08, height * 0.1, 50));
              fill(0, 255, 255); stroke(0); strokeWeight(3);
              text("Yuri 22 Dash Pro", width / 2, height * 0.3);

              textSize(min(width * 0.04, height * 0.05, 24));
              fill(255); noStroke();
              text("Bem-vindo!", width / 2, height * 0.45);
        }

        function saveNickname() {
             if (nicknameInput) {
                 const nick = nicknameInput.value.trim();
                 if (nick && nick.length > 0) {
                     playerNickname = nick;
                     updateProfileArea(); // Atualiza o display no perfil
                     saveGameData(); // Salva o nick no localStorage
                     console.log("Nickname salvo:", playerNickname);
                     changeState("menu"); // Vai para o menu após salvar
                 } else {
                     alert("Por favor, digite um nickname válido.");
                     playerNickname = "Convidado"; // Volta para convidado se inválido
                     updateProfileArea();
                     saveGameData();
                     changeState("menu"); // Vai para o menu mesmo se inválido
                 }
             }
        }

        function startGame() {
            console.log("startGame: Iniciando...");
             // Permite iniciar do gameover também (via botão Reiniciar)
             if (!assetsReady || !['menu', 'nickname', 'gameover'].includes(gameState)) {
                 console.warn("startGame: Chamada ignorada (estado/assets inválidos). Estado atual:", gameState);
                 return;
             }

             try {
                 score = 0;
                 currentLevel = 1;
                 playerLives = MAX_PLAYER_LIVES;
                 hasRevived = false;
                 reviveShakeTimer = 0;
                 reviveLightTimer = 0;
                 obstacles = [];
                 playerParticles = [];
                 boss = null; // Garante que começa sem boss
                 bossLevel = 1; // Reseta nível do boss
                 bossRespawnTimer = -1; // Reseta timer de respawn

                 if (player) {
                     player.reset();
                     console.log("startGame: Jogador resetado.");
                 } else {
                     console.error("startGame: Jogador não existe!"); return;
                 }

                 gameStartTime = millis();
                 gameTimer = 0; // Timer agora conta para cima

                 updateScoreDisplay();
                 updateLevelDisplay();
                 updateLivesDisplay();
                 updateTimerDisplay();
                 updateBossCountdownDisplay(BOSS_APPEAR_TIME, "Boss em"); // Mostra contagem inicial

                 // Habilidade Reset
                 abilityAvailable = false;
                 currentAbilityType = null;
                 abilityReady = false;
                 abilityCooldownTimer = 0;
                 killAbilityClicks = 0;
                 updateAbilityButton();

                 targetZoom = 1.25;

                 // Garante que menus extras estão escondidos
                 if (skinContainer) skinContainer.style.display = "none";
                 if (instructionsPanel) instructionsPanel.style.display = 'none';
                 if (nicknameArea) nicknameArea.style.display = 'none';
                 if (particleColorSelector) particleColorSelector.style.display = "none";
                 if (bossHealthBarContainer) bossHealthBarContainer.style.display = 'none'; // Esconde barra de vida

                 console.log("startGame: Preparação concluída, mudando para 'play'");
                 changeState("play");
                 showMessage("Desvie dos Obstáculos!", 180); // Mensagem inicial

             } catch(e) {
                 console.error("ERRO dentro de startGame:", e);
                 changeState("menu");
             }
        }

        function runGameScreen() {
            if (!player) { console.error("runGameScreen: Player não definido!"); changeState("menu"); return; }

            try {
                // Timer (Conta tempo sobrevivido)
                let elapsedMillis = millis() - gameStartTime;
                let elapsedSeconds = floor(elapsedMillis / 1000);
                gameTimer = elapsedSeconds; // Timer agora é o tempo decorrido
                updateTimerDisplay();

                // --- Lógica Principal ---
                player.update();
                player.show();

                // --- Obstáculos Normais ---
                let baseSpawnRate = 100;
                let levelSpawnReduction = 4; // Reduzido um pouco para menos spawn em níveis altos
                let spawnRate = max(25, baseSpawnRate - (currentLevel * levelSpawnReduction)); // Mínimo 25 frames

                // Gera obstáculos normais APENAS se o Boss não estiver ativo E não estiver esperando respawn
                if (!boss && bossRespawnTimer <= 0 && frameCount % floor(spawnRate) === 0) {
                    obstacles.push(new Obstacle(currentLevel));
                }

                // Atualiza e desenha obstáculos normais
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    let obs = obstacles[i];
                    obs.update();
                    obs.show();

                    // Colisão com obstáculos normais
                    if (obs.hits(player)) {
                        console.log("runGameScreen: Colisão com obstáculo normal!");
                        handlePlayerHit();
                        if (gameState === 'gameover') return;
                        obstacles.splice(i, 1); // Remove o obstáculo que colidiu
                        continue;
                    }

                    if (obs.offscreen()) {
                        obstacles.splice(i, 1);
                        score++;
                        updateScoreDisplay();
                        checkLevelUp();
                    }
                }

                // --- Lógica do Boss ---
                let bossInitialSpawnRemaining = BOSS_APPEAR_TIME - elapsedSeconds;

                // 1. Aparecimento do PRIMEIRO Boss
                if (!boss && bossLevel === 1 && bossRespawnTimer <= 0 && bossInitialSpawnRemaining <= 0) {
                    console.log("runGameScreen: Primeiro Boss (Nível 1) vai aparecer!");
                    showMessage(`CHEFE NÍVEL ${bossLevel} CHEGANDO!`, 180);
                    obstacles = []; // Limpa obstáculos normais
                    boss = new Boss(bossImg, bossLevel); // Cria Boss nível 1
                    killAbilityClicks = 0;
                    updateBossCountdownDisplay(-1); // Esconde countdown
                    updateAbilityButton(); // Habilita o botão de habilidade se o nível permitir
                    if (bossHealthBarContainer) bossHealthBarContainer.style.display = 'block'; // MOSTRA barra de vida
                }
                // 2. Countdown para o PRIMEIRO Boss (antes dele aparecer)
                else if (!boss && bossLevel === 1 && bossRespawnTimer <= 0 && bossInitialSpawnRemaining > 0) {
                    updateBossCountdownDisplay(bossInitialSpawnRemaining, "Boss em");
                }
                // 3. Countdown para RESPAWN do próximo Boss (após um ser derrotado)
                else if (!boss && bossRespawnTimer > 0) {
                    bossRespawnTimer--;
                    updateBossCountdownDisplay(ceil(bossRespawnTimer / 60), "Próximo em"); // Mostra contagem regressiva

                    // Respawn do Boss
                    if (bossRespawnTimer <= 0) {
                        console.log(`runGameScreen: Respawn do Boss (Nível ${bossLevel})!`);
                        showMessage(`CHEFE NÍVEL ${bossLevel} APARECEU!`, 150);
                        obstacles = []; // Limpa obstáculos normais remanescentes
                        boss = new Boss(bossImg, bossLevel); // Cria novo Boss com nível atual
                        killAbilityClicks = 0;
                        updateBossCountdownDisplay(-1); // Esconde countdown
                        updateAbilityButton();
                        if (bossHealthBarContainer) bossHealthBarContainer.style.display = 'block'; // MOSTRA barra de vida
                    }
                }
                // 4. Atualização do Boss quando ATIVO
                else if (boss) {
                    boss.update(player);
                    boss.show(); // Desenha o corpo do boss

                    // Checa colisão dos projéteis do boss com o player (agora são desenhados separadamente)
                     for (let i = boss.projectiles.length - 1; i >= 0; i--) {
                         let p = boss.projectiles[i];
                         if (p.hits(player)) {
                             console.log("runGameScreen: Colisão com projétil do Boss!");
                             boss.projectiles.splice(i, 1); // Remove projétil
                             handlePlayerHit();
                             if (gameState === 'gameover') return;
                             continue;
                         } else if (p.offscreen()) {
                             boss.projectiles.splice(i, 1);
                         }
                     }

                     // Verifica se o boss foi derrotado (pela habilidade)
                    if (boss.health <= 0) {
                        console.log(`Boss Nível ${bossLevel} Derrotado!`);
                        showMessage(`Chefe Nv.${bossLevel} Derrotado! Próximo em 20s`, 180);
                        score += 50 * bossLevel; // Bonus maior por bosses mais difíceis
                        updateScoreDisplay();

                        // Efeito simples de partículas na derrota
                        let defeatX = boss.x;
                        let defeatY = boss.y;
                        for(let i = 0; i < 30; i++) {
                             let angle = random(TWO_PI);
                             let speed = random(3, 8);
                             playerParticles.push(new PlayerParticle(defeatX, defeatY, cos(angle)*speed, sin(angle)*speed, 60, [255, 69, 0])); // Laranja/Vermelho
                        }

                        bossLevel++; // Incrementa nível para o próximo boss
                        bossRespawnTimer = BOSS_RESPAWN_INTERVAL; // Inicia timer para o próximo
                        boss = null; // Remove o boss atual
                        if (bossHealthBarContainer) bossHealthBarContainer.style.display = 'none'; // ESCONDE barra de vida

                        updateAbilityButton(); // Atualiza estado botão (deve ficar inapropriado ou esquiva)
                        updateBossCountdownDisplay(ceil(bossRespawnTimer / 60), "Próximo em"); // Mostra countdown inicial pro próximo
                    }
                }
                // Garante que o countdown está escondido se o boss estiver ativo
                else if (boss && bossCountdownDisplay && bossCountdownDisplay.style.display !== 'none') {
                     bossCountdownDisplay.style.display = 'none';
                }


            } catch (e) {
                console.error("ERRO em runGameScreen:", e);
                changeState("gameover");
            }
        }

        // Função para lidar com o jogador sendo atingido
        function handlePlayerHit() {
            if (player.isInvincible()) return;

             if (!hasRevived) {
                 hasRevived = true;
                 playerLives = 0; // Usa a "vida" do revive
                 updateLivesDisplay(); // Atualiza display (vai mostrar 0)
                 player.flash(120); // Flash mais longo para indicar revive/invencibilidade (2 segundos)
                 startReviveEffects();
                 console.log("REVIVE USADO! Ultima chance gasta.");
                 showMessage("REVIVIDO! Ultima Chance!", 150);
                 // Opcional: Tocar som de reviver
                 // NOVO: Feedback de dano - pequeno flash vermelho (temporário)
                // push();
                // fill(255, 0, 0, 100); // Vermelho semi-transparente
                // rect(0, 0, width, height); // Cobre a tela toda brevemente
                // pop();
                // // A animação de flash do player e o shake já dão feedback
             } else {
                 playerLives = 0; // Garante que vidas fiquem 0
                 updateLivesDisplay();
                 console.log("Sem revives restantes. GAME OVER.");
                 changeState("gameover");
             }
        }

        // Função para iniciar efeitos visuais do revive
        function startReviveEffects() {
             reviveShakeTimer = 30; // Shake mais intenso
             reviveLightTimer = 40; // Luz mais duradoura
            // Adiciona um overlay flash rápido
           const flashOverlay = document.createElement('div');
           flashOverlay.className = 'revive-flash-overlay';
           gameContainer.elt.appendChild(flashOverlay);
           setTimeout(() => flashOverlay.remove(), 600); // Remove após a animação
        }

        // Função para mostrar mensagens na tela
        function showMessage(text, duration = 180) { // duration em frames (3 segundos a 60fps)
            displayMessage = text;
            displayMessageTimer = duration;
        }

        function showMenuScreen() {
              textAlign(CENTER, CENTER);
              textSize(min(width * 0.08, height * 0.1, 50));
              fill(0, 255, 255); stroke(0); strokeWeight(3);
              text("Yuri 22 Dash Pro", width / 2, height * 0.3);

              // Nick e Nível Máximo agora estão no #profileArea (HTML)

              textSize(min(width * 0.03, height * 0.04, 20));
              fill(255); noStroke();
              text("Use [ESPAÇO] ou [TOQUE] para pular!", width / 2, height * 0.55);
              // Atualiza instruções se necessário
              if (instructionsContent) updateInstructionsContent();


        }

        function showPausedScreen() {
            // Redesenha elementos do jogo parados
             if(player) player.show(true); // Força opaco
             for (let obs of obstacles) { obs.show(); }
             if(boss) {
                 boss.show(); // Corpo
                 // Desenha aviso e projéteis PARADOS
                push();
                if (boss.warningTimer > 0 && boss.warningPosition) {
                    boss.drawWarning(); // Desenha aviso parado
                }
                for (let p of boss.projectiles) {
                    p.show(); // Desenha projéteis parados
                }
                pop();
             }
             // Overlay HTML é controlado pelo changeState
        }

        function showGameOverScreen() {
             if(player) player.show(true); // Mostra estado final (sem piscar)
             for (let obs of obstacles) { obs.show(); }
             if(boss) { boss.show(); for(let p of boss.projectiles) { p.show(); } } // Mostra estado final do boss/projéteis

             // Mensagem Game Over (desenhada no canvas, sob o zoom)
             textAlign(CENTER, CENTER);
             textSize(min(width * 0.1, height * 0.15, 60));
             fill(255, 0, 0); stroke(0); strokeWeight(4);
             text("GAME OVER", width / 2, height * 0.4);

             textSize(min(width * 0.05, height * 0.06, 30));
             fill(255); noStroke();
             text("Score Final: " + score, width / 2, height * 0.55);
             text("Nível Final: " + currentLevel, width / 2, height * 0.65);
             text("Tempo: " + formatTime(gameTimer), width / 2, height * 0.75); // Mostra tempo sobrevivido

             // Botões "Voltar ao Menu" e "Reiniciar" são criados/mostrados pelo changeState
        }

        function goToMenu() {
             if (gameState === 'loading' || gameState === 'menu') return;
             console.log("goToMenu: Voltando para o menu.");

             // Salva o nível MÁXIMO alcançado nesta partida
             if (currentLevel > highestLevelReached) {
                 highestLevelReached = currentLevel;
                 console.log("Novo nível máximo salvo:", highestLevelReached);
                 updateProfileArea(); // Atualiza display do perfil
             }
             saveGameData(); // Salva dados (nível máximo, skin, nick, cor partícula)

             targetZoom = 1.0; // Reseta zoom ao voltar pro menu

             changeState("menu");
        }

        function togglePause() {
             if (gameState === "play") { changeState("paused"); }
             else if (gameState === "paused") { changeState("play"); }
        }

        function checkLevelUp() {
             let reachedNewLevel = false;
            if (currentLevel + 1 < levelScoreThresholds.length && score >= levelScoreThresholds[currentLevel + 1]) {
                currentLevel++;
                reachedNewLevel = true;
                console.log("Level Up! Nível:", currentLevel);
                updateLevelDisplay();
                showLevelUpAnimation();

                // Verifica se habilidade é desbloqueada/atualizada
                 if (currentLevel === 3 && !abilityAvailable) {
                     abilityAvailable = true;
                     currentAbilityType = 'dodge';
                     abilityReady = true;
                     console.log("Habilidade 'Esquiva Rápida' Desbloqueada!");
                     showMessage("Esquiva Rápida (Nível 3) Desbloqueada!", 200);
                     updateAbilityButton();
                 } else if (currentLevel === 6 && currentAbilityType !== 'kill') { // Só atualiza se não for kill ainda
                     abilityAvailable = true; // Garante que está disponível
                     currentAbilityType = 'kill'; // Muda para a habilidade de matar
                     abilityReady = true; // Pronta para usar
                     console.log("Habilidade 'Tiro Certeiro' Desbloqueada!");
                     showMessage("Tiro Certeiro (Nível 6) Desbloqueado!", 200);
                     killAbilityClicks = 0; // Reseta contagem de kill se acabou de liberar
                     updateAbilityButton();
                 }

                 // Atualiza o nível máximo se necessário (durante o jogo)
                 if (currentLevel > highestLevelReached) {
                     highestLevelReached = currentLevel;
                     updateProfileArea();
                     // Atualiza visualmente as skins desbloqueadas se o menu estiver aberto
                     if (skinContainer && skinContainer.style.display === "flex") {
                         populateSkinContainer();
                     }
                     saveGameData(); // Salva o novo nível máximo imediatamente
                 }
            }
             return reachedNewLevel;
        }

        // --- Funções de Desenho Auxiliares ---
        function drawBackground() {
            background(10, 10, 30);
            fill(255, 255, 255, 150); noStroke();
            let speedMultiplier = (gameState === 'play' ? (1 + currentLevel * 0.05 + (boss ? bossLevel * 0.02 : 0)) : (gameState === 'menu' ? 0.2 : 0)); // Leve aceleração com bossLevel se boss existe
            for (let star of stars) {
                ellipse(star.x, star.y, star.size, star.size);
                if (gameState === 'play' || gameState === 'menu') {
                    star.x -= star.speed * speedMultiplier;
                    if (star.x < -star.size) { star.x = width + star.size; star.y = random(height); }
                }
            }
             // Desenho do Chão
             fill(40, 40, 60);
             rect(0, height - groundMargin, width, groundMargin);
             // Linha superior do chão
             stroke(80, 80, 100);
             strokeWeight(2);
             line(0, height - groundMargin, width, height - groundMargin);
             noStroke(); // Reset stroke
        }

        function showLevelUpAnimation() {
            if (!levelUpDisplay) return;
            levelUpDisplay.innerText = `NÍVEL ${currentLevel}!`;
            levelUpDisplay.style.opacity = 1;
            levelUpDisplay.style.transform = 'translateX(-50%) scale(1.2)';
            setTimeout(() => {
                if (levelUpDisplay) {
                     levelUpDisplay.style.opacity = 0;
                     levelUpDisplay.style.transform = 'translateX(-50%) scale(1)';
                }
            }, 1500);
        }

        // Partículas do jogador
        function updateAndDrawPlayerParticles() {
             for (let i = playerParticles.length - 1; i >= 0; i--) {
                 playerParticles[i].update();
                 playerParticles[i].show();
                 if (playerParticles[i].isFinished()) {
                     playerParticles.splice(i, 1);
                 }
             }
        }

        // Formata tempo em M:SS
        function formatTime(totalSeconds) {
            let minutes = floor(totalSeconds / 60);
            let seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // --- Funções de UI e Interação ---
        function getHtmlElements() {
            console.log("getHtmlElements: Pegando elementos...");
            try {
                backButton = document.getElementById('backButton');
                skinButton = document.getElementById('skinButton');
                pauseButton = document.getElementById('pauseButton');
                abilityButton = document.getElementById('abilityButton');
                skinContainer = document.getElementById('skinContainer');
                loadingMessage = document.getElementById('loadingMessage');
                scoreDisplay = document.getElementById('scoreDisplay');
                levelDisplay = document.getElementById('levelDisplay');
                livesDisplay = document.getElementById('livesDisplay');
                timerDisplay = document.getElementById('timerDisplay');
                bossCountdownDisplay = document.getElementById('bossCountdown');
                pauseOverlay = document.getElementById('pauseOverlay');
                levelUpDisplay = document.getElementById('levelUpDisplay');
                instructionsPanel = document.getElementById('instructionsPanel');
                instructionsContent = document.getElementById('instructionsContent');
                closeInstructionsButton = document.getElementById('closeInstructionsButton');
                nicknameArea = document.getElementById('nicknameArea');
                nicknameInput = document.getElementById('nicknameInput');
                nicknameButton = document.getElementById('nicknameButton');
                particleColorSelector = document.getElementById('particleColorSelector');
                profileArea = document.getElementById('profileArea');
                profilePic = document.getElementById('profilePic');
                profileNicknameDisplay = document.getElementById('profileNicknameDisplay');
                profileLevelDisplay = document.getElementById('profileLevelDisplay');
                profileSettingsIcon = document.getElementById('profileSettingsIcon');
                footerCopyright = document.getElementById('footerCopyright');
                // NOVO: Barra de Vida Boss
                bossHealthBarContainer = document.getElementById('bossHealthBarContainer');
                bossHealthBar = document.getElementById('bossHealthBar');
                bossHealthText = document.getElementById('bossHealthText');


                if (!backButton || !skinButton || !pauseButton || !abilityButton || !skinContainer || !loadingMessage || !scoreDisplay || !levelDisplay || !livesDisplay || !timerDisplay || !bossCountdownDisplay || !pauseOverlay || !levelUpDisplay || !p5ButtonContainer || !instructionsPanel || !closeInstructionsButton || !nicknameArea || !nicknameInput || !nicknameButton || !particleColorSelector || !profileArea || !profilePic || !profileNicknameDisplay || !profileLevelDisplay || !profileSettingsIcon || !footerCopyright || !bossHealthBarContainer || !bossHealthBar || !bossHealthText ) {
                    console.warn("ERRO: Um ou mais elementos HTML essenciais não foram encontrados! Verifique os IDs.");
                } else {
                    console.log("getHtmlElements: Elementos encontrados.");
                }
            } catch (e) { console.error("ERRO em getHtmlElements:", e); }
        }

        function configureOverlayButtons() {
             if (backButton) backButton.onclick = goToMenu;
             if (skinButton) skinButton.onclick = toggleSkinSelect;
             if (pauseButton) pauseButton.onclick = togglePause;
             if (closeInstructionsButton) closeInstructionsButton.onclick = hideInstructionsPanel;
             if (nicknameButton) nicknameButton.onclick = saveNickname;
             if (abilityButton) abilityButton.onclick = useAbility;
             if (profileSettingsIcon) profileSettingsIcon.onclick = () => { alert('Configurações de perfil ainda em desenvolvimento!'); };
             console.log("configureOverlayButtons: Botões HTML configurados.");
        }

        // Mostrar/Esconder Painel Instruções
        function showInstructionsPanel() { if (instructionsPanel) instructionsPanel.style.display = 'flex'; updateInstructionsContent(); }
        function hideInstructionsPanel() { if (instructionsPanel) instructionsPanel.style.display = 'none'; }
         // Atualiza conteúdo das instruções dinamicamente
         function updateInstructionsContent() {
             if (!instructionsContent) return;
             // O conteúdo base está no HTML, aqui podemos adicionar detalhes se necessário
              // Ex: Se alguma feature mudar dinamicamente
              // Re-inicializa ícones Lucide se presentes nas instruções
             if (typeof lucide !== 'undefined') {
                  try { lucide.createIcons({ context: instructionsContent }); } catch(e) {}
              }
         }

        // Funções para criar/remover botões p5 dinamicamente
        function removeAllP5Buttons() {
             if (playButtonP5) { playButtonP5.remove(); playButtonP5 = null; }
             if (instructionsButtonP5) { instructionsButtonP5.remove(); instructionsButtonP5 = null; }
             if (gameOverMenuButtonP5) { gameOverMenuButtonP5.remove(); gameOverMenuButtonP5 = null; }
             if (gameOverRestartButtonP5) { gameOverRestartButtonP5.remove(); gameOverRestartButtonP5 = null; }
        }

        function createMenuButtons() {
             removeAllP5Buttons();
             if (!playButtonP5) {
                 playButtonP5 = createButton("Jogar")
                     .class("p5Button")
                     .parent(p5ButtonContainer)
                     .mousePressed(startGame);
             }
             if (!instructionsButtonP5) {
                 instructionsButtonP5 = createButton("Instruções")
                     .class("p5Button secondary")
                     .parent(p5ButtonContainer)
                     .mousePressed(showInstructionsPanel);
             }
        }

        function createGameOverButtons() {
             removeAllP5Buttons();
             if (!gameOverMenuButtonP5) {
                 gameOverMenuButtonP5 = createButton("Voltar ao Menu")
                     .class("p5Button secondary")
                     .parent(p5ButtonContainer)
                     .mousePressed(goToMenu);
             }
             if (!gameOverRestartButtonP5) {
                 gameOverRestartButtonP5 = createButton("Reiniciar")
                     .class("p5Button")
                     .parent(p5ButtonContainer)
                     .mousePressed(startGame);
             }
        }

        function changeState(newState) {
             if (gameState === newState) return;
             console.log(`changeState: ${gameState} -> ${newState}`);
             let oldState = gameState;
             gameState = newState;

             // Remove botões p5 antigos
             removeAllP5Buttons();

             // Controle Elementos HTML Overlay e UI (esconde tudo primeiro)
              const elementsToManage = [
                   backButton, skinButton, pauseButton, abilityButton, pauseOverlay,
                   scoreDisplay, levelDisplay, livesDisplay, timerDisplay, bossCountdownDisplay,
                   skinContainer, instructionsPanel, nicknameArea, particleColorSelector,
                   profileArea, bossHealthBarContainer // Adicionado container da barra de vida
              ];
              elementsToManage.forEach(el => { if (el) el.style.display = 'none'; });

             // Controle do Loop p5
             // Não chamar noLoop() em gameover para botões p5 funcionarem
             if (['paused', 'nickname'].includes(newState)) {
                 if (isLooping()) { console.log(`changeState: Chamando noLoop() para estado ${newState}`); noLoop(); }
             } else if (!isLooping()) {
                 console.log(`changeState: Chamando loop() para estado ${newState}`); loop();
             }

             // Mostra elementos e cria botões p5 para o NOVO estado
             if(p5ButtonContainer) p5ButtonContainer.elt.style.display = 'none';

             switch (newState) {
                 case "nickname":
                     if (nicknameArea) nicknameArea.style.display = 'flex';
                     if (nicknameInput) nicknameInput.focus();
                     targetZoom = 1.0;
                     break;
                 case "menu":
                     createMenuButtons();
                     if(p5ButtonContainer) p5ButtonContainer.elt.style.display = 'flex';
                     if (skinButton) skinButton.style.display = 'block';
                     if (particleColorSelector) particleColorSelector.style.display = 'flex';
                     if (profileArea) profileArea.style.display = 'flex';
                     targetZoom = 1.0;
                     break;
                 case "play":
                 case "paused":
                     if (backButton) backButton.style.display = 'block';
                     if (skinButton) skinButton.style.display = 'block';
                     if (pauseButton) { pauseButton.style.display = 'block'; pauseButton.innerText = (newState === 'paused' ? "Continuar" : "Pausar"); }
                     if (abilityButton) abilityButton.style.display = 'flex';
                     if (scoreDisplay) scoreDisplay.style.display = 'block';
                     if (levelDisplay) levelDisplay.style.display = 'block';
                     if (livesDisplay) livesDisplay.style.display = 'block';
                     if (timerDisplay) timerDisplay.style.display = 'block';
                     // Mostra countdown se aplicável (início ou respawn) E não pausado
                     if (bossCountdownDisplay && newState !== 'paused' && ((!boss && bossLevel === 1 && (millis() - gameStartTime)/1000 < BOSS_APPEAR_TIME) || bossRespawnTimer > 0) ) {
                         bossCountdownDisplay.style.display = 'block';
                     }
                     if (newState === 'paused' && pauseOverlay) pauseOverlay.style.display = 'flex';

                     // NOVO: Mostra barra de vida se o boss existir
                     if (boss && bossHealthBarContainer) {
                         bossHealthBarContainer.style.display = 'block';
                         updateBossHealthBar(); // Atualiza o preenchimento inicial
                     }

                     updateAbilityButton();
                     if(newState === 'play' && oldState !== 'paused') targetZoom = 1.25;
                     else if (newState === 'paused') targetZoom = 1.1;
                     break;
                 case "gameover":
                     createGameOverButtons();
                     if(p5ButtonContainer) p5ButtonContainer.elt.style.display = 'flex';
                     if (scoreDisplay) scoreDisplay.style.display = 'block';
                     if (levelDisplay) levelDisplay.style.display = 'block';
                     if (livesDisplay) { // Mostra Vidas zeradas
                          livesDisplay.innerText = "Vidas: 0";
                          livesDisplay.style.display = 'block';
                     }
                     if (timerDisplay) timerDisplay.style.display = 'block'; // Mostra timer final
                     targetZoom = 1.0;
                     break;
             }
        }


        function keyPressed() {
             if (gameState === 'nickname' && keyCode === ENTER) {
                 saveNickname();
                 return false;
             }
             if ((key === 'p' || key === 'P') && (gameState === 'play' || gameState === 'paused')) {
                 togglePause(); return false;
             }
             // PULO (TECLADO)
             if (gameState === 'play' && (key === " " || keyCode === UP_ARROW)) {
                 if (player) player.jump();
                 return false; // Previne scroll
             }
             // Tecla para Habilidade (ex: 'E') - Opcional
              if (gameState === 'play' && (key === 'e' || key === 'E')) {
                 useAbility(); return false;
              }
             return true;
        }

         // Handler de toque APENAS para o canvas
         function handleCanvasTouch(event) {
              console.log("Canvas Touch detected. Gamestate:", gameState);
              let targetElement = event.target;
              // Verifica se o toque foi em algum botão HTML/p5 ou menu
             if(targetElement.closest('.overlay-button, .p5Button, #skinContainer, #instructionsPanel, #nicknameArea, #particleColorSelector, #profileArea')) {
                 console.log("Touch on UI element, ignoring for jump/pause.");
                  return true; // Deixa o elemento HTML lidar
             }

              // PULO (TOQUE)
              if (gameState === 'play' && player) {
                  player.jump();
                  return false; // Previne scroll/zoom
              }
              else if (gameState === 'paused') {
                  togglePause();
                  return false;
              }
              return true;
         }

         // --- Funções de Skin ---
         function toggleSkinSelect() {
                if (!skinContainer || !skinButton || !gameContainer) return;
                if (skinContainer.style.display === "none" || skinContainer.style.display === "") {
                    populateSkinContainer(); // Popula/Atualiza ao abrir
                    skinContainer.style.display = "flex";
                    // Ajusta posição (lógica mantida)
                    const skinButtonRect = skinButton.getBoundingClientRect();
                    const containerRect = gameContainer.elt.getBoundingClientRect();
                    let topPos = (skinButtonRect.bottom - containerRect.top + 5);
                    let rightPos = (containerRect.right - skinButtonRect.right);
                    let availableHeight = window.innerHeight - topPos - 20;
                    let maxHeight = Math.min(availableHeight, window.innerHeight * 0.7);
                    skinContainer.style.top = topPos + 'px';
                    skinContainer.style.right = rightPos + 'px';
                    skinContainer.style.maxHeight = maxHeight + 'px';
                } else {
                    skinContainer.style.display = "none";
                }
         }


         function populateSkinContainer() {
                if (!skinContainer) { console.error("populateSkinContainer: Container não encontrado!"); return; }
                skinContainer.innerHTML = '';
                console.log("populateSkinContainer: Populando skins. Nível Máximo:", highestLevelReached);

                let skinsExist = false;
                for (const key in playerSkins) {
                    skinsExist = true;
                    const skin = playerSkins[key];
                    const isUnlocked = highestLevelReached >= skin.unlockLevel;

                    const entryDiv = document.createElement('div');
                    entryDiv.classList.add('skin-entry');
                    entryDiv.dataset.skinKey = key;
                    if (!isUnlocked) entryDiv.classList.add('locked');
                    if (key === selectedSkinKey) entryDiv.classList.add('selected');

                    const img = document.createElement('img');
                    img.classList.add('skinOption');
                    img.alt = skin.name;
                    img.title = `${skin.name} (${skin.rarity}) - ${isUnlocked ? 'Desbloqueada' : `Nível ${skin.unlockLevel}`}`;

                    // Lógica de Imagem com Fallback (mantida)
                    if (skin.loadedImg && skin.loadedImg.width > 0 && skin.loadedImg.height > 0) {
                        img.src = skin.loadedImg.src;
                    } else {
                         if (skin.img) {
                             img.src = skin.img;
                         } else {
                             const bgColor = skin.color ? `${skin.color[0].toString(16).padStart(2, '0')}${skin.color[1].toString(16).padStart(2, '0')}${skin.color[2].toString(16).padStart(2, '0')}` : 'cccccc';
                             const faceText = skin.face ? encodeURIComponent(skin.face) : '?';
                             const placeholderUrl = `https://placehold.co/60x60/${bgColor}/000?text=${faceText}&font=pressstart2p`;
                             img.src = placeholderUrl;
                         }
                    }

                    // Fallback final usando onerror (mantido)
                    img.onerror = function() {
                         console.warn(`populateSkinContainer: Falha ao carregar ${this.src}. Usando placeholder final.`);
                         const bgColor = skin.color ? `${skin.color[0].toString(16).padStart(2, '0')}${skin.color[1].toString(16).padStart(2, '0')}${skin.color[2].toString(16).padStart(2, '0')}` : 'cccccc';
                         const faceText = skin.face ? encodeURIComponent(skin.face) : 'ERR';
                         const fallbackUrl = `https://placehold.co/60x60/${bgColor}/333?text=${faceText}&font=pressstart2p`;
                         if (this.src !== fallbackUrl) {
                             this.src = fallbackUrl;
                         }
                         this.onerror = null;
                    };


                    const nameSpan = document.createElement('span'); nameSpan.classList.add('skin-name'); nameSpan.innerText = skin.name;
                    const raritySpan = document.createElement('span'); raritySpan.classList.add('skin-rarity', `rarity-${skin.rarity}`); raritySpan.innerText = skin.rarity;

                    entryDiv.appendChild(img);
                    entryDiv.appendChild(nameSpan);
                    entryDiv.appendChild(raritySpan);

                    if (!isUnlocked) {
                         const lockOverlay = document.createElement('div'); lockOverlay.classList.add('lock-overlay');
                         const lockIcon = document.createElement('i'); lockIcon.setAttribute('data-lucide', 'lock');
                         const unlockSpan = document.createElement('span'); unlockSpan.classList.add('skin-unlock'); unlockSpan.innerText = `Nível ${skin.unlockLevel}`;
                         lockOverlay.appendChild(lockIcon); lockOverlay.appendChild(unlockSpan);
                         entryDiv.appendChild(lockOverlay);
                    } else {
                         entryDiv.onclick = () => selectSkin(key);
                    }
                    skinContainer.appendChild(entryDiv);
                }

                if (!skinsExist) { skinContainer.innerHTML = '<span>Nenhuma skin encontrada.</span>'; }

                if (typeof lucide !== 'undefined') {
                    try { lucide.createIcons(); } catch(e) { console.warn("Erro ao criar ícones Lucide:", e); }
                } else { console.warn("populateSkinContainer: Biblioteca Lucide não carregada."); }
         }


         function selectSkin(key) {
                if (!playerSkins[key]) { console.warn("selectSkin: Skin inválida:", key); return; }
                if (highestLevelReached < playerSkins[key].unlockLevel) {
                    console.log("selectSkin: Skin bloqueada (Nível Máximo insuficiente):", key);
                    return;
                }
                selectedSkinKey = key;
                console.log("selectSkin: Skin selecionada:", selectedSkinKey);
                if (player) { player.setAppearance(playerSkins[selectedSkinKey]); }
                updateSelectedSkinVisual();
                updateProfilePic();
                saveGameData();
                if(skinContainer) skinContainer.style.display = "none";
         }

         function updateSelectedSkinVisual() {
                if (!skinContainer || skinContainer.style.display === 'none') return;
                document.querySelectorAll('.skin-entry').forEach(el => el.classList.remove('selected'));
                const selectedEntry = skinContainer.querySelector(`.skin-entry[data-skin-key="${selectedSkinKey}"]`);
                if (selectedEntry) { selectedEntry.classList.add('selected'); }
         }

         // --- Funções de UI Update ---
         function updateScoreDisplay() { if (scoreDisplay) scoreDisplay.innerText = "Score: " + score; }
         function updateLevelDisplay() { if (levelDisplay) levelDisplay.innerText = "Nível: " + currentLevel; }
         function updateLivesDisplay() { if (livesDisplay) livesDisplay.innerText = "Vidas: " + (hasRevived ? 0 : 1); } // Mostra 1 se revive disponível, 0 se não
         function updateTimerDisplay() {
             if (timerDisplay) {
                 timerDisplay.innerText = `Tempo: ${formatTime(gameTimer)}`; // Usa tempo decorrido
             }
         }
         // Atualiza display do countdown (usado para spawn inicial e respawn)
        function updateBossCountdownDisplay(remainingSeconds, prefix = "Boss em") {
             if (bossCountdownDisplay) {
                 if (remainingSeconds < 0) {
                     bossCountdownDisplay.style.display = 'none'; // Esconde se tempo negativo
                 } else {
                     let displaySeconds = max(0, floor(remainingSeconds));
                     bossCountdownDisplay.innerText = `${prefix}: ${displaySeconds}s`;
                     bossCountdownDisplay.style.display = 'block'; // Garante que está visível
                 }
             }
         }
         // Atualiza a área de perfil
         function updateProfileArea() {
             if (profileNicknameDisplay) profileNicknameDisplay.innerText = `Nick: ${playerNickname}`;
             if (profileLevelDisplay) profileLevelDisplay.innerText = `Nível Máx: ${highestLevelReached}`;
             updateProfilePic();
         }
          // Atualiza a foto do perfil (lógica mantida)
          function updateProfilePic() {
                if (!profilePic) return;
                const skinData = playerSkins[selectedSkinKey];
                if (skinData) {
                     if (skinData.loadedImg && skinData.loadedImg.width > 0) {
                         profilePic.style.backgroundImage = `url('${skinData.loadedImg.src}')`;
                         profilePic.style.backgroundColor = 'transparent';
                     } else if (skinData.img) {
                         profilePic.style.backgroundImage = `url('${skinData.img}')`;
                         profilePic.style.backgroundColor = 'transparent';
                         const tempImg = new Image();
                         tempImg.onerror = () => { setProfileFallbackColor(skinData); };
                         tempImg.src = skinData.img;
                     }
                     else {
                         setProfileFallbackColor(skinData);
                     }
                } else {
                     profilePic.style.backgroundImage = 'none';
                     profilePic.style.backgroundColor = '#888';
                }
          }
         // Função auxiliar para definir cor de fallback no perfil (mantida)
         function setProfileFallbackColor(skinData) {
             if (!profilePic) return;
              profilePic.style.backgroundImage = 'none';
             if (skinData && skinData.color) {
                 profilePic.style.backgroundColor = `rgb(${skinData.color[0]}, ${skinData.color[1]}, ${skinData.color[2]})`;
             } else {
                 profilePic.style.backgroundColor = '#555';
             }
         }
         // NOVO: Atualiza a Barra de Vida do Boss (HTML)
         function updateBossHealthBar() {
             if (!boss || !bossHealthBar || !bossHealthText || !bossHealthBarContainer) return;

             if (bossHealthBarContainer.style.display !== 'block' && gameState !== 'gameover' ) { // Mostra apenas se não for game over
                 bossHealthBarContainer.style.display = 'block';
             } else if (gameState === 'gameover' && bossHealthBarContainer.style.display === 'block') {
                 bossHealthBarContainer.style.display = 'none'; // Esconde no game over
             }


             const healthPercent = constrain(boss.health / boss.maxHealth, 0, 1) * 100;
             bossHealthBar.style.width = `${healthPercent}%`;
             // bossHealthText.innerText = `BOSS NV ${boss.level} (${floor(healthPercent)}%)`; // Texto com %
              bossHealthText.innerText = `BOSS NV ${boss.level}`; // Texto mais simples
         }


         // --- Função de Habilidade ---
         function updateAbilityButton() {
             if (!abilityButton) return;

             const iconLock = abilityButton.querySelector('[data-lucide="lock"]');
             const iconAbility = abilityButton.querySelector('[data-lucide="zap"]'); // Usaremos 'zap' para ambos
             const iconCooldown = abilityButton.querySelector('[data-lucide="timer"]');
             const textSpan = abilityButton.querySelector('.ability-text');

             if(!iconLock || !iconAbility || !iconCooldown || !textSpan) return; // Safety check

             // Esconde todos os ícones e limpa texto
             iconLock.style.display = 'none';
             iconAbility.style.display = 'none';
             iconCooldown.style.display = 'none';
             textSpan.textContent = '';

             abilityButton.disabled = true;
             abilityButton.classList.remove('locked', 'on-cooldown');

             if ((gameState === 'play' || gameState === 'paused') && abilityAvailable) { // Habilidade liberada E no jogo/pausado
                 // Verifica se a habilidade correta pode ser usada na situação atual
                 let canUseNow = false;
                 if (currentAbilityType === 'kill' && boss) { // Kill só com boss
                     canUseNow = true;
                 } else if (currentAbilityType === 'dodge') { // Dodge sempre (permitindo esquiva mesmo com boss)
                      canUseNow = true;
                 }

                 if (canUseNow && abilityReady) {
                     // Pronto para usar
                     abilityButton.disabled = false;
                     iconAbility.style.display = 'inline'; // Mostra ícone da habilidade
                     textSpan.textContent = currentAbilityType === 'dodge' ? 'Esquiva' : 'Tiro';
                 } else if (canUseNow && !abilityReady) {
                      // Em Cooldown (mas poderia usar se estivesse pronta)
                     abilityButton.disabled = true;
                     abilityButton.classList.add('on-cooldown');
                     iconCooldown.style.display = 'inline'; // Mostra ícone de cooldown
                     if(abilityCooldownTimer > 0) textSpan.textContent = ceil(abilityCooldownTimer / 60);
                     else textSpan.textContent = '...';
                 } else {
                      // Habilidade disponível, mas não pode usar AGORA (ex: Tiro sem Boss)
                     abilityButton.disabled = true;
                     abilityButton.classList.add('locked'); // Reusa estilo locked
                     iconLock.style.display = 'inline';
                     if (currentAbilityType === 'kill' && !boss) textSpan.textContent = 'Só c/ Boss';
                     else textSpan.textContent = 'Nv.' + (currentLevel < 3 ? 3 : 6) ; // Fallback
                 }

             } else {
                 // Bloqueado (sem nível ou fora do jogo)
                 abilityButton.disabled = true;
                 abilityButton.classList.add('locked');
                 iconLock.style.display = 'inline';
                 if (textSpan) textSpan.textContent = `Nv ${currentLevel < 3 ? 3 : 6}`;
             }

             // Recria ícones Lucide
             if (typeof lucide !== 'undefined') { try { lucide.createIcons(); } catch(e){} }
         }


         function useAbility() {
             // Condições para *poder* usar a habilidade no estado atual
             let canUseCondition = false;
             if (abilityReady && gameState === 'play') { // Só funciona se pronta e jogando
                 if (currentAbilityType === 'kill' && boss) { // Kill só com boss
                     canUseCondition = true;
                 } else if (currentAbilityType === 'dodge') { // Dodge sempre (decisão de design)
                     canUseCondition = true;
                 }
             }

              if (!canUseCondition) {
                  console.log("Não pode usar habilidade agora.");
                  // Mensagens de feedback
                  if (gameState !== 'play') showMessage("Só funciona no jogo!", 90);
                  else if (!abilityAvailable) showMessage(`Libera no Nível ${currentLevel < 3 ? 3 : 6}!`, 120);
                  else if (!abilityReady) showMessage("Habilidade Recarregando!", 90);
                  else if (currentAbilityType === 'kill' && !boss) showMessage("Tiro Certeiro só funciona contra o Boss!", 120);
                  return;
              }

              console.log(`Usando habilidade: ${currentAbilityType}`);
              abilityReady = false; // Consome
              abilityCooldownTimer = ABILITY_COOLDOWN; // Inicia cooldown
              updateAbilityButton(); // Atualiza botão para cooldown

              if (currentAbilityType === 'dodge') {
                  player.x += DODGE_DISTANCE;
                  player.x = constrain(player.x, player.w / 2, width - player.w / 2);
                  console.log("Esquiva usada!");
                  showMessage("Esquiva!", 90);
                  // Efeito visual de esquiva
                  for(let i=0; i<15; i++) {
                      let angle = random(TWO_PI);
                      let speed = random(2, 5);
                      playerParticles.push(new PlayerParticle(player.x - DODGE_DISTANCE/2, player.y, cos(angle)*speed, sin(angle)*speed, 20, [171, 71, 188])); // Partículas roxas saindo de trás
                  }

              } else if (currentAbilityType === 'kill') {
                  killAbilityClicks++;
                  console.log(`Clique para matar chefe: ${killAbilityClicks}/3`);
                  showMessage(`Clique Matar Boss: ${killAbilityClicks}/3`, 90);

                  if (killAbilityClicks >= 3) {
                      if (boss) {
                          // Dano fatal baseado na vida máxima do boss atual
                          boss.takeDamage(boss.maxHealth);
                          console.log("Tiro certeiro disparado! Boss deve morrer.");
                          // Mensagem de morte é mostrada quando boss.health <= 0
                           killAbilityClicks = 0; // Reseta após o tiro fatal
                      }
                  } else {
                      // Feedback visual/sonoro de clique? (opcional)
                  }
              }
         }


         // --- Local Storage --- (Lógica mantida)
         function saveGameData() {
              try {
                  localStorage.setItem('yuriDash_highestLevel', highestLevelReached.toString());
                  localStorage.setItem('yuriDash_selectedSkin', selectedSkinKey);
                  localStorage.setItem('yuriDash_nickname', playerNickname);
                  localStorage.setItem('yuriDash_particleColor', JSON.stringify(playerParticleColor));
              } catch (e) {
                  console.error("Erro ao salvar dados no localStorage:", e);
              }
         }

         function loadGameData() {
              try {
                  const savedLevel = localStorage.getItem('yuriDash_highestLevel');
                  if (savedLevel) { highestLevelReached = parseInt(savedLevel, 10) || 1; }

                  const savedSkin = localStorage.getItem('yuriDash_selectedSkin');
                  if (savedSkin && playerSkins[savedSkin]) {
                       if (highestLevelReached >= playerSkins[savedSkin].unlockLevel) {
                           selectedSkinKey = savedSkin;
                       } else {
                           selectedSkinKey = "yuri_comum";
                       }
                  } else {
                        selectedSkinKey = "yuri_comum";
                  }

                  const savedNick = localStorage.getItem('yuriDash_nickname');
                  if (savedNick) { playerNickname = savedNick; }

                  const savedColor = localStorage.getItem('yuriDash_particleColor');
                  if (savedColor) {
                      try {
                          const parsedColor = JSON.parse(savedColor);
                          if (Array.isArray(parsedColor) && parsedColor.length === 3 && parsedColor.every(c => typeof c === 'number')) {
                              playerParticleColor = parsedColor;
                          }
                      } catch (e) { console.warn("Erro ao parsear cor salva:", e); }
                  }

                  console.log("Dados carregados do localStorage.");
              } catch (e) {
                  console.error("Erro ao carregar dados do localStorage:", e);
              }
         }

         // --- Setup Cores Partículas --- (Lógica mantida)
         function setupParticleColorSelector() {
              if (!particleColorSelector) return;
              particleColorSelector.innerHTML = '<label>Cor Partícula:</label>';

              Object.entries(PLAYER_PARTICLE_COLORS).forEach(([name, color]) => {
                  const colorDiv = document.createElement('div');
                  colorDiv.classList.add('color-option');
                  colorDiv.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                  colorDiv.dataset.color = JSON.stringify(color);
                  colorDiv.title = name.charAt(0).toUpperCase() + name.slice(1);

                  if (JSON.stringify(color) === JSON.stringify(playerParticleColor)) {
                      colorDiv.classList.add('selected');
                  }

                  colorDiv.onclick = () => {
                      playerParticleColor = color;
                      document.querySelectorAll('#particleColorSelector .color-option').forEach(el => el.classList.remove('selected'));
                      colorDiv.classList.add('selected');
                      saveGameData();
                      console.log("Cor da partícula alterada para:", name);
                  };
                  particleColorSelector.appendChild(colorDiv);
              });
         }

         // --- Funções Utilitárias ---
         function createStars(){
             stars = [];
             let numStars = constrain(floor(width * height / 3000), 50, 300);
             for (let i = 0; i < numStars; i++) {
                 stars.push({ x: random(width), y: random(height), size: random(1, 3.5), speed: random(0.3, 1.2) });
             }
             console.log("createStars: Estrelas criadas:", stars.length);
         }

         // --- Classes do Jogo ---
         class Player {
              constructor() {
                  this.baseSize = constrain(height * 0.06, 30, 50);
                  this.w = this.baseSize;
                  this.h = this.baseSize;
                  this.x = width * 0.15;
                  this.groundLevel = height - groundMargin;
                  this.y = this.groundLevel - this.h / 2;
                  this.velocity = 0;
                  this.gravity = height * 0.0011;
                  this.jumpForce = -height * 0.025;
                  this.jumpsLeft = 2;
                  this.onGround = true;
                  this.angle = 0;
                  this.rotationSpeed = 0;
                  this.skinImage = null;
                  this.color = [0, 220, 255];
                  this.face = '^_^';
                  this.hitboxPadding = 2; // *** COLISÃO PRECISA ***
                  this.isFlashing = false;
                  this.flashTimer = 0;
                  // Squash & Stretch
                  this.squashFactor = 1.0;
                  this.targetSquashFactor = 1.0;
                  this.squashSpeed = 0.2;
                  this.idleBobTimer = random(TWO_PI);
                  this.idleBobAmount = 1.5;
              }

              setAppearance(skinData) {
                  this.color = skinData.color || [255,0,0];
                  this.face = skinData.face || 'ERR';
                   this.skinImage = (skinData.loadedImg && skinData.loadedImg.width > 0) ? skinData.loadedImg : null;
              }

              isInvincible() {
                  return this.isFlashing && this.flashTimer > 0;
              }

              update() {
                  this.groundLevel = height - groundMargin;
                  let wasOnGround = this.onGround;

                  // Squash Factor Lerp
                  this.squashFactor = lerp(this.squashFactor, this.targetSquashFactor, this.squashSpeed);
                  if (abs(this.targetSquashFactor - 1.0) < 0.01 && abs(this.squashFactor - 1.0) > 0.01) {
                        this.targetSquashFactor = 1.0;
                        this.squashFactor = lerp(this.squashFactor, 1.0, this.squashSpeed * 0.5);
                  }
                  this.h = this.baseSize * sqrt(this.squashFactor);
                  this.w = this.baseSize / sqrt(this.squashFactor);

                  // Physics
                  if (this.y + this.h / 2 < this.groundLevel || this.velocity < 0) {
                      this.velocity += this.gravity;
                       this.onGround = false;
                  }
                  this.y += this.velocity;

                  // Rotation
                  if (!this.onGround) {
                      this.rotationSpeed = this.velocity * 0.02;
                       if(this.targetSquashFactor !== 1.0 && this.velocity > 0) {
                             this.targetSquashFactor = 1.0;
                       }
                  } else {
                      this.rotationSpeed = 0;
                      this.angle = lerp(this.angle, 0, 0.2);
                  }
                  this.angle += this.rotationSpeed;

                  // Ground Check & Correction
                  if (this.y + this.h / 2 >= this.groundLevel && this.velocity >= 0) {
                       this.y = this.groundLevel - this.h / 2;
                       this.velocity = 0;

                       if (!wasOnGround) { // Just Landed
                           this.angle = 0;
                           this.rotationSpeed = 0;
                           this.jumpsLeft = 2; // Reseta pulos
                           this.onGround = true;
                           // Landing Squash Effect
                           this.targetSquashFactor = 0.7;
                            setTimeout(() => { this.targetSquashFactor = 1.0; }, 80);
                           // Landing Particles
                           for(let i=0; i<8; i++){
                                playerParticles.push(new PlayerParticle(this.x, this.y + this.h/2, random(-2, 2), random(-1, -3), 30));
                           }
                       }
                       this.onGround = true;
                  }

                  // Ceiling Check
                  if (this.y - this.h / 2 < 0) {
                       this.y = this.h / 2;
                       if (this.velocity < 0) this.velocity = 0;
                       this.targetSquashFactor = 0.8;
                        setTimeout(() => { this.targetSquashFactor = 1.0; }, 100);
                  }

                  // Idle Bobbing
                  if (this.onGround) {
                       this.idleBobTimer += 0.1;
                       if (!this.isFlashing) {
                           if(this.velocity === 0) {
                                 this.y = (this.groundLevel - this.h / 2) + sin(this.idleBobTimer) * this.idleBobAmount;
                           }
                       }
                  }

                  // Movement Particles (Trail)
                  if (!this.onGround && abs(this.velocity) > 1) {
                       if (frameCount % 4 === 0) {
                           let px = this.x - (this.w / 3 * (this.velocity > 0 ? -1 : 1));
                           let py = this.y + this.h / 3;
                           let vx = random(-0.5, 0.5) - (this.velocity * 0.01);
                           let vy = random(0.5, 1.5);
                            playerParticles.push(new PlayerParticle(px, py, vx, vy));
                       }
                  }

                  // Flash Timer (Invincibility)
                  if (this.isFlashing) {
                        this.flashTimer--;
                        if (this.flashTimer <= 0) {
                            this.isFlashing = false;
                        }
                  }
              }

              jump() {
                  if (this.jumpsLeft > 0) {
                      let currentJumpForce = this.jumpForce;
                      this.velocity = currentJumpForce;
                      this.onGround = false;
                      this.jumpsLeft--;
                      // Jump Stretch Effect
                      this.targetSquashFactor = 1.4;
                      // Jump Particles
                      let numParticles = (this.jumpsLeft === 1) ? 6 : 8;
                      for(let i=0; i < numParticles; i++){
                           playerParticles.push(new PlayerParticle(this.x, this.y + this.h/2, random(-1.5, 1.5), random(1, 3.5), 40));
                      }
                  }
              }


              flash(duration = 15) {
                   this.isFlashing = true;
                   this.flashTimer = duration;
              }

              show(forceOpaque = false) {
                   push();
                   translate(this.x, this.y);
                   rotate(this.angle);
                   rectMode(CENTER);

                   // Flash Logic
                   let showPlayer = true;
                   if (this.isFlashing && !forceOpaque) {
                        showPlayer = floor(this.flashTimer / 4) % 2 === 0;
                   }

                   // Efeito de Luz Branca (Reviver)
                    if (reviveLightTimer > 0) {
                         let lightAlpha = map(reviveLightTimer, 0, 40, 0, 180); // Mais sutil
                         let lightSizeFactor = map(reviveLightTimer, 40, 0, 2.0, 3.0);
                         fill(255, 255, 255, lightAlpha * (showPlayer ? 1 : 0.5));
                         noStroke();
                         ellipse(0, 0, this.w * lightSizeFactor, this.h * lightSizeFactor);
                    }


                   if (showPlayer) {
                        if (this.skinImage) {
                            imageMode(CENTER);
                            image(this.skinImage, 0, 0, this.w, this.h);
                        } else {
                            let fillColor = color(255,0,0);
                            if (this.color && this.color.length >= 3) {
                                 fillColor = color(this.color[0], this.color[1], this.color[2], this.color.length > 3 ? this.color[3] : 255);
                            }
                            fill(fillColor);
                            stroke(0); strokeWeight(2);
                            rect(0, 0, this.w, this.h, this.baseSize * 0.1);

                            fill(0); noStroke(); textAlign(CENTER, CENTER);
                            textSize(this.w * 0.4);
                            text(this.face || '?', 0, this.h * 0.05);
                        }
                   }
                   pop();
              }

              reset() {
                  this.groundLevel = height - groundMargin;
                  this.baseSize = constrain(height * 0.06, 30, 50);
                  this.w = this.baseSize;
                  this.h = this.baseSize;
                  this.y = this.groundLevel - this.h / 2;
                  this.velocity = 0;
                  this.onGround = true;
                  this.jumpsLeft = 2;
                  this.angle = 0;
                  this.rotationSpeed = 0;
                  this.isFlashing = false;
                  this.flashTimer = 0;
                  this.squashFactor = 1.0;
                  this.targetSquashFactor = 1.0;
                  this.idleBobTimer = random(TWO_PI);

                  if (playerSkins && playerSkins[selectedSkinKey]) {
                        this.setAppearance(playerSkins[selectedSkinKey]);
                  } else {
                        this.setAppearance({ name: "Erro", rarity: "Comum", color: [255,0,0], face: 'ERR', unlockLevel: 1, loadedImg: null });
                  }
              }
         }

         // Obstacle Class com mais tipos
         class Obstacle {
              constructor(level) {
                  this.level = level;
                  this.groundLevel = height - groundMargin;

                  this.baseSpeed = width * 0.007;
                  this.speedIncreasePerLevel = width * 0.0005;
                  this.speed = this.baseSpeed + (this.level * this.speedIncreasePerLevel) + random(-width*0.0005, width*0.0008);
                  this.speed = max(this.speed, width * 0.005);

                  this.x = width + random(50, 150);

                  let pSize = (player && player.baseSize) ? player.baseSize : constrain(height * 0.06, 30, 50);
                  this.size = random(pSize * 0.8, pSize * 1.3); // Tamanho base (altura spike, largura block, diâmetro circle)
                  this.blockHeight = random(pSize * 0.8, pSize * 1.5); // Altura específica do bloco

                  this.verticalSpeed = 0;
                  this.hitboxPadding = 1; // *** COLISÃO PRECISA ***
                  this.color = color(255, 50, 50); // Cor padrão (vermelho spike)

                  // Define o tipo (spike, block, circle, triangle_up, rectangle_tall)
                  this.type = 'spike'; // Default
                  let typeRoll = random();
                  let blockChance = 0.3 + level * 0.01; // Aumenta chance com nível
                  let circleChance = 0.15 + level * 0.01;
                  let triangleChance = 0.1 + level * 0.015; // Triângulos mais comuns em níveis altos
                  let tallRectChance = 0.05 + level * 0.01;

                  if (level >= 2) {
                       if (typeRoll < tallRectChance) { this.type = 'rectangle_tall'; }
                       else if (typeRoll < tallRectChance + triangleChance) { this.type = 'triangle_up'; }
                       else if (typeRoll < tallRectChance + triangleChance + circleChance) { this.type = 'circle'; }
                       else if (typeRoll < tallRectChance + triangleChance + circleChance + blockChance) { this.type = 'block'; }
                       // else: continua 'spike'
                  }

                  // Propriedades específicas por tipo
                  switch (this.type) {
                       case 'block':
                            this.color = color(200, 200, 220);
                            this.size = random(pSize * 1.0, pSize * 1.8); // Largura
                            this.y = this.groundLevel - this.blockHeight;
                            // Movimento vertical para blocos (chance aumenta com nível)
                            if (level >= 3 && random() < (0.2 + level * 0.02)) {
                                 this.verticalSpeed = random(height * 0.002, height * 0.004) * (random() > 0.5 ? 1 : -1);
                                 this.y = this.groundLevel - this.blockHeight - random(height * 0.05, height * 0.15);
                            }
                            break;
                       case 'circle':
                            this.color = color(50, 200, 50);
                            this.size = random(pSize * 0.7, pSize * 1.2); // Diâmetro
                            this.y = this.groundLevel - this.size / 2 - random(0, pSize * 0.3); // Flutua um pouco
                            // Movimento vertical para círculos (chance aumenta com nível)
                            if (level >= 4 && random() < (0.15 + level * 0.02)) {
                               this.verticalSpeed = random(height * 0.001, height * 0.003) * (random() > 0.5 ? 1 : -1);
                               this.y = this.groundLevel - this.size / 2 - random(height * 0.05, height * 0.1);
                            }
                            break;
                      case 'triangle_up':
                            this.color = color(255, 100 + random(50), 0); // Laranja/Amarelo
                            this.y = this.groundLevel; // Base no chão
                            this.size = random(pSize * 0.8, pSize * 1.3); // Altura do triângulo
                            break;
                       case 'rectangle_tall':
                            this.color = color(180, 180, 200); // Cinza claro diferente do bloco
                            this.size = random(pSize * 0.4, pSize * 0.7); // Largura (fino)
                            this.blockHeight = random(pSize * 1.5, pSize * 2.5); // Altura (bem alto)
                            this.y = this.groundLevel - this.blockHeight;
                            break;
                       case 'spike': // Default
                            this.color = color(255, 50 + random(50), 50 + random(50));
                            this.y = this.groundLevel;
                            this.size = random(pSize * 0.9, pSize * 1.4); // Altura
                            break;
                  }

                  // Chance Rara de ser Maior (aumenta com nível)
                  if (level >= 4 && random() < (0.08 + level * 0.01)) {
                       let scaleFactor = random(1.3, 1.8);
                       this.size *= scaleFactor;
                       if (this.type === 'block' || this.type === 'rectangle_tall') {
                             this.blockHeight *= scaleFactor * 0.8; // Aumenta altura proporcionalmente menos
                             if (this.verticalSpeed === 0) this.y = this.groundLevel - this.blockHeight; // Recalcula Y estático
                       }
                       // Ajustar Y para círculo estático maior se necessário
                  }
              }

              update() {
                  this.x -= this.speed;

                  // Movimento vertical (Blocos e Círculos Móveis)
                  if (this.verticalSpeed !== 0) {
                        this.y += this.verticalSpeed;
                        const topLimit = height * 0.3;
                        let bottomLimit;
                        if (this.type === 'block' || this.type === 'rectangle_tall') bottomLimit = this.groundLevel - this.blockHeight;
                        else if (this.type === 'circle') bottomLimit = this.groundLevel - this.size / 2;
                        else bottomLimit = this.groundLevel; // Should not happen for moving spikes

                        let currentTop = this.y - (this.type === 'circle' ? this.size / 2 : (this.type === 'spike' || this.type === 'triangle_up' ? this.size : 0) ); // Topo real
                        let currentBottom = this.y + (this.type === 'block' || this.type === 'rectangle_tall' ? 0 : this.size / 2 ); // Base real


                        if (currentTop < topLimit || this.y > bottomLimit) { // Bateu no teto ou no "chão virtual"
                            // Correção de posição
                            if (this.type === 'block' || this.type === 'rectangle_tall'){ this.y = constrain(this.y, topLimit, bottomLimit); }
                            else if (this.type === 'circle') { this.y = constrain(this.y, topLimit + this.size / 2, bottomLimit + this.size / 2); }

                            this.verticalSpeed *= -1; // Inverte direção
                        }
                  }
              }

              show() {
                  push();
                  try { fill(this.color); } catch (e) { fill(255,0,0); } // Fallback color
                  stroke(0);
                  strokeWeight(1.5);

                  translate(this.x, 0); // Translada só no X para facilitar desenho no chão

                  switch (this.type) {
                       case 'spike':
                            triangle(-this.size / 2.5, this.y, this.size / 2.5, this.y, 0, this.y - this.size);
                            break;
                      case 'triangle_up': // Espinho para cima
                            triangle(-this.size / 2.5, this.y, this.size / 2.5, this.y, 0, this.y - this.size);
                            break;
                       case 'block':
                            rectMode(CORNER);
                            rect(-this.size / 2, this.y, this.size, this.blockHeight, 3); // Usa this.y (calculado no update)
                            break;
                       case 'rectangle_tall':
                            rectMode(CORNER);
                            rect(-this.size / 2, this.y, this.size, this.blockHeight, 2);
                            break;
                       case 'circle':
                            ellipseMode(CENTER);
                            ellipse(0, this.y, this.size, this.size); // Usa this.y (calculado no update)
                            break;
                  }
                  pop();
              }

              offscreen() {
                  return (this.x + this.size) < 0; // Usa size como largura máxima aproximada
              }

              hits(player) {
                  if (!player || player.isInvincible()) return false;

                  let pL = player.x - player.w / 2 + player.hitboxPadding;
                  let pR = player.x + player.w / 2 - player.hitboxPadding;
                  let pT = player.y - player.h / 2 + player.hitboxPadding;
                  let pB = player.y + player.h / 2 - player.hitboxPadding;

                  let oL, oR, oT, oB;

                  if (this.type === 'circle') {
                      // Colisão Círculo-Retângulo (Aproximação AABB) - mais simples e geralmente ok
                      oL = this.x - this.size / 2 + this.hitboxPadding;
                      oR = this.x + this.size / 2 - this.hitboxPadding;
                      oT = this.y - this.size / 2 + this.hitboxPadding;
                      oB = this.y + this.size / 2 - this.hitboxPadding;
                  } else if (this.type === 'spike' || this.type === 'triangle_up') {
                      // Hitbox AABB simplificada para triângulos (meio da base até o topo)
                       oL = this.x - this.size / 3 + this.hitboxPadding; // Base mais larga na hitbox
                       oR = this.x + this.size / 3 - this.hitboxPadding;
                       oT = this.y - this.size + this.hitboxPadding * 2; // Começa um pouco abaixo do topo real
                       oB = this.y - this.hitboxPadding;
                  } else { // block ou rectangle_tall
                       oL = this.x - this.size / 2 + this.hitboxPadding;
                       oR = this.x + this.size / 2 - this.hitboxPadding;
                       oT = this.y + this.hitboxPadding; // Topo do bloco
                       oB = this.y + this.blockHeight - this.hitboxPadding; // Base do bloco
                  }

                  // AABB Check
                  if (pR > oL && pL < oR && pB > oT && pT < oB) {
                       return true;
                  }
                  return false;
              }
         }

         // Classe Boss Atualizada
         class Boss {
              constructor(img, level = 1) { // Recebe nível do boss
                  this.img = img;
                  this.level = level; // Armazena o nível do boss
                  this.size = constrain(width * 0.15, 80, 150);
                  this.x = width + this.size;
                  this.y = height / 3;
                  this.speedX = -width * 0.002;
                  this.speedY = height * 0.003 + (level * height * 0.0002); // Aumenta velocidade Y com nível
                  this.state = 'entering';
                  this.projectiles = []; // Renomeado de 'particles'
                  this.attackCooldown = 0;

                  // Dificuldade baseada no nível
                  this.attackInterval = max(30, 90 - (level * 5)); // Diminui intervalo com nível (mín 30 frames)
                  this.particleSpeed = width * (0.006 + (level * 0.0004)); // Aumenta velocidade projétil
                  this.numParticlesMin = 1 + floor(level / 3); // Mais projéteis min com nível
                  this.numParticlesMax = 3 + floor(level / 2); // Mais projéteis max com nível

                  this.hitboxPadding = 5; // Colisão um pouco mais precisa com o corpo
                  this.verticalRange = { top: height * 0.1, bottom: height - groundMargin - this.size * 0.8 };

                  // NOVO: Vida escalável
                  this.maxHealth = Math.max(1, 1 + Math.floor((level - 1) / 2)); // Vida = 1 + 1 a cada 2 níveis (1, 1, 2, 2, 3, 3...)
                  this.health = this.maxHealth;

                  // NOVO: Aviso de ataque
                  this.warningTimer = 0; // Timer para o aviso
                  this.warningPosition = null; // Onde o aviso vai aparecer
                  this.warningSize = player ? player.baseSize * 1.8 : 60; // Tamanho do aviso


                  console.log(`Boss Nível ${this.level} criado. Vida: ${this.maxHealth}, Intervalo Atk: ${this.attackInterval}, Vel Proj: ${this.particleSpeed.toFixed(2)}`);
              }

              update(player) {
                  if (this.health <= 0) return;

                  if (this.state === 'entering') {
                      this.x += this.speedX;
                      if (this.x <= width - this.size * 1.2) {
                          this.x = width - this.size * 1.2;
                          this.speedX = 0;
                          this.state = 'attacking';
                          this.attackCooldown = 60; // Primeiro ataque
                      }
                  } else if (this.state === 'attacking') {
                      // Movimento Vertical
                      this.y += this.speedY;
                      if (this.y - this.size/2 < this.verticalRange.top || this.y + this.size/2 > this.verticalRange.bottom) {
                          this.y = constrain(this.y, this.verticalRange.top + this.size/2, this.verticalRange.bottom - this.size/2);
                          this.speedY *= -1;
                      }
                      // Ataque (com aviso)
                      this.attackCooldown--;

                      // NOVO: Lógica de Aviso
                      if (this.warningTimer > 0) {
                          this.warningTimer--;
                          if (this.warningTimer === 0 && this.warningPosition) {
                              // Fim do aviso, dispara projéteis
                              this.fireProjectiles(this.warningPosition);
                              this.warningPosition = null; // Limpa aviso
                          }
                      }
                      // Verifica se pode iniciar um novo ataque (cooldown e sem aviso ativo)
                      else if (this.attackCooldown <= 0) {
                          this.prepareAttack(player); // Prepara o aviso e o alvo
                          this.attackCooldown = this.attackInterval + random(-15, 15); // Reinicia cooldown para o *próximo* ataque
                      }
                  }
                  // Atualiza projéteis (movido para fora da lógica de estado, mas apenas se boss existe)
                   for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        this.projectiles[i].update();
                        // Remoção agora é feita em runGameScreen
                   }
              }

              // NOVO: Prepara o ataque (define aviso)
              prepareAttack(player) {
                  if (!player || this.warningTimer > 0) return; // Só prepara se não houver aviso ativo

                  // Calcula posição alvo (com erro)
                  let aimErrorX = player.w * random(-0.9, 0.9);
                  let aimErrorY = player.h * random(-0.9, 0.9);
                  let targetX = player.x + aimErrorX;
                  let targetY = player.y + aimErrorY;

                  // Define a posição e o timer do aviso
                  this.warningPosition = { x: targetX, y: targetY };
                  this.warningTimer = BOSS_ATTACK_WARNING_DURATION; // Inicia contagem do aviso

                  console.log(`Boss preparando ataque em (${targetX.toFixed(0)}, ${targetY.toFixed(0)})`);
              }

              // NOVO: Dispara projéteis (chamado após o aviso)
              fireProjectiles(targetPos) {
                  let numProjectiles = floor(random(this.numParticlesMin, this.numParticlesMax + 1));
                   for (let i = 0; i < numProjectiles; i++) {
                       let pX = this.x - this.size / 2;
                       let pY = this.y + random(-this.size * 0.3, this.size * 0.3);

                       // Mira no centro da área de aviso com pequena variação
                       let angle = atan2(targetPos.y - pY + random(-this.warningSize*0.2, this.warningSize*0.2),
                                        targetPos.x - pX + random(-this.warningSize*0.2, this.warningSize*0.2));

                       let speedVariation = random(0.85, 1.15); // Menos variação talvez?
                       let pVX = cos(angle) * this.particleSpeed * speedVariation;
                       let pVY = sin(angle) * this.particleSpeed * speedVariation;

                       this.projectiles.push(new BossProjectile(pX, pY, pVX, pVY));
                   }
                   console.log(`Boss disparou ${numProjectiles} projéteis.`);
              }

              // Desenha apenas o corpo do Boss
              show() {
                  if (this.health <= 0) return;
                  push();
                  if (this.img && this.img.width > 0) {
                      imageMode(CENTER);
                      image(this.img, this.x, this.y, this.size, this.size);
                  } else { // Fallback
                      fill(255, 0, 0, 200); stroke(0); strokeWeight(2);
                      rectMode(CENTER); rect(this.x, this.y, this.size, this.size);
                      fill(255); noStroke(); textSize(this.size * 0.2); // Texto menor
                      textAlign(CENTER, CENTER); text(`BOSS ${this.level}`, this.x, this.y); // Mostra Nível
                  }
                  pop();
              }

              // NOVO: Desenha Aviso e Projéteis (chamado separadamente no draw())
              drawProjectilesAndWarning() {
                  if (this.health <= 0) return;
                  push();

                  // Desenha Aviso
                  if (this.warningTimer > 0 && this.warningPosition) {
                      this.drawWarning();
                  }

                  // Desenha Projéteis
                  for (let i = this.projectiles.length - 1; i >= 0; i--) {
                       this.projectiles[i].show();
                    }
                   pop();
              }

              // NOVO: Função auxiliar para desenhar o aviso
              drawWarning() {
                   if (!this.warningPosition) return;

                   // Animação do aviso (pulsar ou crescer)
                   let timeRatio = (BOSS_ATTACK_WARNING_DURATION - this.warningTimer) / BOSS_ATTACK_WARNING_DURATION; // 0 -> 1
                   let pulseFactor = 0.8 + 0.2 * abs(sin(timeRatio * PI * 3)); // Pulsar entre 0.8 e 1.0
                   let currentSize = this.warningSize * pulseFactor; // Tamanho pulsante
                   // let currentSize = this.warningSize * (1 + timeRatio * 0.3); // Ou Cresce um pouco
                   let alpha = 180 + 75 * sin(timeRatio * PI * 4); // Pisca alpha mais rápido (180-255)

                   noFill();
                   strokeWeight(max(2, this.warningSize * 0.05));
                   stroke(255, 0, 0, alpha); // Vermelho piscando
                   ellipse(this.warningPosition.x, this.warningPosition.y, currentSize, currentSize);

                   // Centro opcional para melhor visibilidade
                   // fill(255, 0, 0, alpha * 0.5);
                   // noStroke();
                   // ellipse(this.warningPosition.x, this.warningPosition.y, 10, 10);
              }

              takeDamage(amount) {
                  this.health -= amount;
                  this.health = max(0, this.health); // Garante que não fique negativo
                  console.log(`Boss tomou ${amount} de dano. Vida restante: ${this.health}/${this.maxHealth}`);
                  updateBossHealthBar(); // Atualiza a barra de vida imediatamente
                  // Add damage effect? (flash red?)
              }
         }

         // *** Boss Projectile - AGORA COM VISUAL DE FOGO ***
         class BossProjectile {
              constructor(x, y, vx, vy) {
                  this.x = x; this.y = y;
                  this.vx = vx; this.vy = vy;
                  this.baseSize = random(18, 28); // Tamanho base da bola de fogo
                  this.size = this.baseSize;
                  // Cor removida, será feita com gradiente
                  this.hitboxPadding = 2; // *** COLISÃO PRECISA *** AJUSTADO
                  this.angle = random(TWO_PI);
                  this.rotationSpeed = random(-0.03, 0.03); // Rotação mais lenta
                  this.life = 180; // Tempo de vida em frames (3s a 60fps) para fade out
              }
              update() {
                  this.x += this.vx;
                  this.y += this.vy;
                  this.angle += this.rotationSpeed;
                  this.life--;
                  // Fade out size
                  this.size = this.baseSize * (max(0, this.life) / 180); // Usa max(0, life)
                  // this.size = max(0, this.size); // Garantido acima

                  // Opcional: Adicionar leve gravidade ou outro comportamento
                   this.vy += 0.03; // Leve gravidade
              }
              show() {
                   if (this.life <= 0 || this.size <= 0) return; // Não desenha se morto ou tamanho 0
                   push();
                   translate(this.x, this.y);
                   rotate(this.angle);
                   noStroke();

                   let alpha = map(this.life, 0, 60, 0, 255); // Fade out rápido no final
                   alpha = constrain(alpha, 0, 255);

                   // Desenha a bola de fogo com camadas e gradiente simulado
                   // Camada externa (vermelho escuro/laranja)
                   fill(255, 100, 0, alpha * 0.7);
                   ellipse(0, 0, this.size, this.size);

                   // Camada média (laranja/amarelo)
                   fill(255, 165, 0, alpha * 0.9);
                   ellipse(0, 0, this.size * 0.75, this.size * 0.75);

                   // Camada interna (amarelo/branco)
                   fill(255, 255, 150, alpha);
                   ellipse(0, 0, this.size * 0.4, this.size * 0.4);

                   pop();
              }
              offscreen() {
                  // Considera o tempo de vida também
                   if (this.life <= 0) return true;
                   const margin = this.baseSize * 2; // Usa baseSize para margem maior
                   return this.x < -margin || this.x > width + margin || this.y < -margin || this.y > height + margin;
              }
              hits(player) {
                  if (!player || player.isInvincible() || this.life <= 0 || this.size <=0) return false;

                  let pL = player.x - player.w / 2 + player.hitboxPadding;
                  let pR = player.x + player.w / 2 - player.hitboxPadding;
                  let pT = player.y - player.h / 2 + player.hitboxPadding;
                  let pB = player.y + player.h / 2 - player.hitboxPadding;

                  // Hitbox AABB baseada no tamanho ATUAL da bola de fogo
                   let hitSize = this.size * 0.7; // Hitbox 70% do tamanho visual atual
                   hitSize = max(5, hitSize); // Garante hitbox mínima

                   let oL = this.x - hitSize / 2 + this.hitboxPadding;
                   let oR = this.x + hitSize / 2 - this.hitboxPadding;
                   let oT = this.y - hitSize / 2 + this.hitboxPadding;
                   let oB = this.y + hitSize / 2 - this.hitboxPadding;

                   if (pR > oL && pL < oR && pB > oT && pT < oB) {
                       return true;
                   }
                   return false;
              }
         }


         // Player Particle Class (Mantida)
          class PlayerParticle {
                constructor(x, y, vx, vy, life = 40, forceColor = null) {
                    this.x = x;
                    this.y = y;
                    this.vx = vx + random(-0.3, 0.3);
                    this.vy = vy + random(-0.3, 0.3);
                    this.initialLife = life + random(-10, 10);
                    this.life = max(5, this.initialLife);
                    this.size = random(3, 6);
                    this.color = forceColor || playerParticleColor || [255, 255, 255];
                }
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 0.05; // Gravity
                    this.vx *= 0.98; // Drag
                    this.life--;
                }
                show() {
                    push();
                    let alpha = map(this.life, 0, this.initialLife, 0, 200);
                    fill(this.color[0], this.color[1], this.color[2], alpha);
                    noStroke();
                    ellipse(this.x, this.y, this.size * (this.life / this.initialLife)); // Shrink
                    pop();
                }
                isFinished() {
                    return this.life <= 0;
                }
          }


         // --- Funções de Janela ---
         function windowResized() {
              console.log("windowResized: Redimensionando...");
              resizeCanvas(windowWidth, windowHeight);
              console.log(`windowResized: Canvas redimensionado para ${width}x${height}`);

              // Recalcula margem chão
               groundMargin = constrain(windowHeight * 0.15, 80, 150);
              console.log(`windowResized: Nova margem chão: ${groundMargin}`);

              createStars();

               if (player) {
                   player.reset(); // Recalcula propriedades baseadas no tamanho
                   player.y = player.groundLevel - player.h / 2; // Garante posição Y
               }

               // Atualiza obstáculos existentes
              obstacles.forEach(obs => {
                   obs.groundLevel = height - groundMargin;
                   if (obs.type === 'spike' || obs.type === 'triangle_up') { obs.y = obs.groundLevel; }
                   else if ((obs.type === 'block' || obs.type === 'rectangle_tall') && obs.verticalSpeed === 0) { obs.y = obs.groundLevel - obs.blockHeight; }
                   // Recalcula velocidade baseada na largura
                   obs.baseSpeed = width * 0.007;
                   obs.speedIncreasePerLevel = width * 0.0005;
                   obs.speed = obs.baseSpeed + (obs.level * obs.speedIncreasePerLevel) + random(-width*0.0005, width*0.0008);
                   obs.speed = max(obs.speed, width * 0.005);
              });


               if (boss) {
                    boss.size = constrain(width * 0.15, 80, 150);
                    if (boss.state === 'attacking') boss.x = width - boss.size * 1.2;
                    boss.verticalRange = { top: height * 0.1, bottom: height - groundMargin - boss.size * 0.8 };
                    boss.y = constrain(boss.y, boss.verticalRange.top + boss.size/2, boss.verticalRange.bottom - boss.size/2);
                    boss.speedY = height * 0.003 + (boss.level * height * 0.0002); // Recalcula velocidade Y
                    boss.particleSpeed = width * (0.006 + (boss.level * 0.0004)); // Recalcula velocidade projétil
                    // Recalcula tamanho do aviso
                    boss.warningSize = player ? player.baseSize * 1.8 : 60;
               }

               // Reaplica estado para garantir UI correta
               if (gameState !== 'loading') {
                  // Força um redesenho completo chamando changeState novamente
                  // Evita problemas de layout dos botões p5
                  let currentState = gameState;
                  gameState = "resizing"; // Estado temporário
                  changeState(currentState);
               }

               // Fecha menus se estiverem abertos (evita problemas de posicionamento)
               if (skinContainer && skinContainer.style.display !== 'none') {
                    skinContainer.style.display = 'none';
               }
               if (particleColorSelector && particleColorSelector.style.display !== 'none') {
                    particleColorSelector.style.display = 'none';
                    if(gameState === 'menu') particleColorSelector.style.display = 'flex'; // Reabre se estava no menu
               }
               if (instructionsPanel && instructionsPanel.style.display !== 'none') {
                   instructionsPanel.style.display = 'none';
               }


              console.log("windowResized: Processamento completo.");
         }

    </script>
</body>
</html>
